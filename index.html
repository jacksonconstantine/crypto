<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Fluid</title>
<style>
  :root{
  --base-font-size:14px;
    --bg:#0b0d10; 
    --surface:#0d1217; 
    --surface-2:#0f1419;
    --border:#1a1a1a; 
    --fg:#e8eef3; 
    --muted:#aab7c4;
    --pos:#16c784; 
    --neg:#ea3943; 
    --accent:#86b9ff; 
    --accent-2:#5ca8ff;

    /* layout rhythm */
    --gap:16px;
    --pad-h:16px;
    --pad-v:14px;
    --wrap-margin:clamp(12px,2vh,20px);

    /* measured at runtime to align chart to table content */
    --chart-pad-r:16px;      /* distance from canvas right edge to plot end */
    --chart-pad-l-base:100px;/* min left pad to align with PRICE */
    --chart-left-nudge:-6px; /* negative moves plot slightly further left to match table dividers */

    /* footer */
    --footer-height:56px;
    /* fixed viewport gutters for both widgets and footer */
    --side-gutter: clamp(12px, 2vw, 24px);
  }

  /* Light mode overrides */
  body.light{
    --bg:#f7fafc;
    --surface:#ffffff;
    --surface-2:#f3f6fa;
    --border:#e2e8f0;
    --fg:#0b0d10;
    --muted:#556274;
    --pos:#059669;
    --neg:#dc2626;
    --accent:#2563eb;
    --accent-2:#3b82f6;
  }

  /* Center the entire dashboard (falls back on short screens) */
  html,body{height:100%}
  body{
    min-height:100svh; margin:0;
    background:var(--bg); color:var(--fg);
  font-size:var(--base-font-size);
  /* Use the system UI / Apple font stack for a native Apple-like look */
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-variant-numeric:tabular-nums;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    display:flex; align-items:center; justify-content:center;
    padding-bottom: calc(var(--footer-height) + var(--wrap-margin));
  }
  @media (max-height:780px){ body{ align-items:flex-start; } }

  /* Outer container: fixed gutters vs viewport and a max content width */
  .wrap{
    box-sizing:border-box;
    width:100%;
    max-width:1600px;
    margin:var(--wrap-margin) auto;
    padding-inline: var(--side-gutter);
    position:relative;
    min-height: calc(100svh - var(--footer-height));
    display:flex; align-items:center;
  }

  /* Outer card: make background/border transparent by default (panels keep their own surface) */
  .card{
    background: transparent; /* was a gradient using --surface / --surface-2 */
    border:1px solid transparent; /* keep layout but visually remove the border */
    border-radius:14px;
    width:100%;
  }
  .screen{ padding:var(--pad-v) var(--pad-h); display:flex; flex-direction:column; gap:var(--gap); }

  /* Panels */
  .panel{ background:linear-gradient(180deg,var(--surface) 0%,var(--surface-2) 100%); border:1px solid var(--border); border-radius:14px; padding:12px var(--pad-h); min-width:0; }

  /* Table */
  .panel-table{ overflow:hidden; }
  .table-wrap{ width:100%; overflow-x:auto; overflow-y:hidden; }
  table.data{
    width:100%;
    border-collapse:separate; border-spacing:0; table-layout:fixed;
  /* min-width is computed in JS from 10ch * column count */
  }

  /* ---- UNIFORM COLUMNS (smaller min width for denser layout) ---- */
  table.data col { width: var(--colw, 6ch); }
  thead th, tbody td{
    /* reduce the min to 10ch so columns can be narrower */
    min-width:10ch;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }

  thead th{
    position:sticky; top:0; z-index:1;
    background:transparent;
    border-bottom:1px solid var(--border);
    color:var(--muted); padding:10px 8px;
  }
  thead th:first-child{ text-align:left; }
  thead th.num{ text-align:right; }
  tbody td{ padding:10px 8px; border-bottom:1px solid var(--border); }
  td.coin{ display:flex; align-items:center; gap:8px; text-align:left; letter-spacing:.1px; }
  td.num, th.num{ text-align:right; }
  /* Use a single solid separator color for consistency */
  .group-sep{ border-left:1px solid var(--border); }

  /* Cleaned duplicates: sel-dot defined once */
  .sel-dot{ width:7px; height:7px; border-radius:999px; background:var(--accent); opacity:.9; visibility:hidden; }
  .row-selected .sel-dot{ visibility:visible; }
  body.chart-off .sel-dot{ display:none !important; }

  .muted{ color:var(--muted); }
  .pos{ color:var(--pos); } .neg{ color:var(--neg); }

  /* Hover “elevate” — apply only on devices that support hover (desktop) */
  tbody tr{
    cursor:pointer;
    transition:transform .12s ease, box-shadow .12s ease, background-color .12s ease;
    /* remove the native tap highlight on mobile browsers */
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    touch-action: manipulation;
  }
  /* Reduce hover shadow and use a subtle background so separators don't change contrast */
  @media (hover: hover) and (pointer: fine) {
  tbody tr:hover{ transform:translateX(-1px); background: color-mix(in srgb, var(--accent) 12%, transparent); box-shadow:0 1px 4px rgba(0,0,0,.08); }
  /* Match legend period item hover with table row hover affordance but avoid horizontal movement to prevent flicker */
  #chartLegend .legend-period-item:hover{ background: color-mix(in srgb, var(--accent) 12%, transparent); box-shadow:0 1px 4px rgba(0,0,0,.08); }
  }

  /* Prevent mobile browsers from leaving a persistent focus/active highlight on rows */
  tbody tr:focus, tbody tr:active, tbody tr:focus-visible{
    outline: none !important;
    background: transparent !important;
    box-shadow: none !important;
  }

  /* Selection inverse (highlight) */
  ::selection{ background:#fff; color:#000; }
  ::-moz-selection{ background:#fff; color:#000; }

  /* Flash on price update */
  @keyframes flashUp{0%{background:rgba(22,199,132,.17)}100%{background:transparent}}
  @keyframes flashDown{0%{background:rgba(234,57,67,.17)}100%{background:transparent}}
  td.flash-up{ animation:flashUp .28s ease; }
  td.flash-down{ animation:flashDown .28s ease; }
  @media (prefers-reduced-motion:reduce){ td.flash-up,td.flash-down{ animation:none; } }

  /* Chart */
  .panel-chart{ position:relative; }
  .chart-head{
    display:flex; align-items:center; justify-content:space-between; color:var(--muted);
    margin:0 0 8px 0;
    padding-right:8px; /* timestamp aligns with rightmost table content (cell padding) */
    position:relative; /* allow absolute positioning of the axis for pixel-perfect alignment */
  }
  canvas#chart{
    width:100%; height:300px; display:block; border:none; border-radius:12px;
    background:transparent; /* transparent area behind chart */
  }
  /* Loading overlay that sits over the chart without removing the canvas underneath */
  .panel-chart{ position:relative; }
  .panel-chart .loading-overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:4;
    background:linear-gradient(180deg, rgba(11,13,16,0.6), rgba(11,13,16,0.6));
    color:var(--muted); border-radius:12px; opacity:0; pointer-events:none; transition:opacity .18s ease;
  }
  .panel-chart .loading-overlay.visible{ opacity:1; pointer-events:auto; }
  .panel-chart .loading-overlay .spinner{
    width:26px; height:26px; border-radius:50%; border:3px solid rgba(255,255,255,0.06); border-top-color:var(--accent); animation:spin .9s linear infinite; margin-right:10px;
  }
  .panel-chart .loading-overlay .label{ font-size:calc(var(--base-font-size) - 1px); color:var(--muted); }
  @keyframes spin{ to{ transform:rotate(360deg); } }

  /* DOM-based vertical guide (replaces canvas-drawn guide for pixel-exact positioning) */
  #chartGuide{
    position:absolute;
    top:0; left:0;
    width:1px; pointer-events:none; z-index:50;
    background: rgba(255,255,255,0.14);
    transform: translateX(-0.5px);
    will-change: left, top, height, opacity;
    opacity:0; transition: opacity .06s linear;
  }
  #chartGuide.visible{ opacity:1; }


  /* Tooltip styles for chart hover */
  #chartTooltip{
    position: fixed;
    pointer-events: none;
    background: color-mix(in srgb, var(--surface) 92%, transparent);
    color: var(--fg);
    border: 1px solid var(--border);
    padding: 8px 10px;
    border-radius: 8px;
    font-size: calc(var(--base-font-size) - 1px);
    box-shadow: 0 6px 24px rgba(0,0,0,.5);
    white-space: nowrap;
    z-index: 60;
    transform-origin: left top;
    transition: opacity .12s ease, transform .12s ease;
    opacity: 0; transform: translateY(-6px) scale(.98);
  }
  #chartTooltip.visible{ display:block; opacity:1; transform: translateY(0) scale(1); }
  #chartTooltip .tt-line{ color:var(--muted); display:block; margin-bottom:4px; }
  #chartTooltip .tt-price{ font-weight:600; display:block; }

  /* Smoothen table and price transitions to avoid abrupt jumps */
  td.c-price{ transition: color .18s ease, opacity .12s ease, background-color .28s ease; }

  /* Footer / status bar */
  .footer{
    position:fixed; left:0; right:0; bottom:0; z-index:60;
    display:flex; justify-content:center; pointer-events:auto;
  }

  /* Hide scrollbars visually for kiosk mode (Chromium) while keeping scroll behavior.
    Also disable vertical page scrolling entirely for a locked kiosk view; overlays
    (fixed position) keep their internal scrolling via their own overflow rules. */
  /* Firefox */
  html, body { scrollbar-width: none; -ms-overflow-style: none; overflow-y: hidden; }
  /* WebKit/Chromium */
  html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0; height: 0; }
  /* Hide the horizontal scrollbar on the table wrapper but keep scrolling via wheel/trackpad */
  .table-wrap { scrollbar-width: none; -ms-overflow-style: none; }
  .table-wrap::-webkit-scrollbar { height: 0; }

  .footer .inner{
    box-sizing:border-box;
    /* leave a consistent horizontal margin so the status bar doesn't touch the viewport edges */
    width: calc(100% - (var(--side-gutter) * 2));
    margin-inline: var(--side-gutter);
    padding:10px 0 14px 0;
    display:flex; justify-content:space-between; align-items:center; gap:12px;
    color:var(--muted);
    background:transparent;
    border:none; border-radius:0;
  }
  .hint{ display:flex; gap:10px; flex-wrap:wrap; }
  .kbd{ background:rgba(255,255,255,.04); border:1px solid var(--border); padding:2px 6px; border-radius:6px; font:inherit; color:var(--fg); }

  /* Legend preview clickable items */
  /* Legend preview clickable items - uniform muted styling */
  /* Legend should follow the global base font size */
  #chartLegend{ font-size:var(--base-font-size); }
  /* New: legend split into four equal sections */
  #chartLegend{ display:flex; align-items:center; gap:12px; width:100%; }
  #chartLegend .legend-section{ flex:1; display:flex; align-items:center; justify-content:flex-start; min-width:0; }
  #chartLegend .legend-section.token{ justify-content:flex-start; font-weight:400; }
  #chartLegend .legend-section.periods{ justify-content:center; }
  #chartLegend .legend-section.granularity{ justify-content:center; }
  #chartLegend .legend-section.axis{ justify-content:flex-end; }
  #chartLegend .legend-prev, #chartLegend .legend-next{
    display:inline-block;
    padding:4px 6px;
    border-radius:6px;
    border:1px solid transparent;
    /* use explicit left/right margins per element below to get exact spacing */
    font-size:var(--base-font-size);
    color:var(--muted);
    background:transparent;
  }
  #chartLegend .legend-prev:hover, #chartLegend .legend-next:hover{ background:rgba(255,255,255,.02); border-color:var(--border); }
  /* token removed; period and arrows use the same muted style and spacing */
  /* spacing: left gap from title -> prev bubble comes from chart-head gap (8px) + no extra left margin here */
  #chartLegend .legend-prev{ margin-left:0; margin-right:1px; }
  #chartLegend .legend-period{ padding:4px 8px; border-radius:6px; background:transparent; color:var(--muted); font-weight:400; margin:0 6px; }
  /* individual period items inside the periods subsection */
  /* use a small ch-based component so the bubble grows slightly with text length
    while keeping a stable base padding. This avoids 3-char labels like "24h"
    feeling too tight compared to 2-char labels. */
  #chartLegend .legend-period-item{ padding:6px calc(10px + 0.6ch); border-radius:9px; background:transparent; color:var(--muted); margin:0 6px; display:inline-flex; align-items:center; justify-content:center; min-width:0; }
  #chartLegend .legend-period-item{ transition: box-shadow .12s ease, background-color .12s ease; border:1px solid transparent; box-sizing:border-box; }
  #chartLegend .legend-period-item.selected{ background:rgba(255,255,255,.04); color:var(--fg); font-weight:400; border:1px solid var(--border); }
  #chartLegend .legend-period-item:focus{ outline:none; box-shadow:0 0 0 3px rgba(92,168,255,.06); border-color:var(--accent-2); }
  #chartLegend .legend-next{ margin-left:1px; margin-right:0; }
  /* interval separated from right bubble by 8px */
  #chartLegend .legend-interval{ margin-left:8px; color:var(--muted); font-size:var(--base-font-size); font-weight:400; }
  /* KBD-like items inside the legend should match muted appearance */
  #chartLegend .kbd{ background:rgba(255,255,255,.02); border:1px solid var(--border); color:var(--muted); padding:2px 6px; border-radius:6px; font:inherit; }

  /* Keep lookbacks present (don’t hide) so horizontal scroll works consistently */
  @media (max-width:1200px){ col.lb-30d, th.lb-30d, td.lb-30d{display:table-cell;} }
  @media (max-width:1100px){ col.lb-7d,  th.lb-7d,  td.lb-7d {display:table-cell;} }
  @media (max-width:1020px){ col.lb-24h, th.lb-24h, td.lb-24h{display:table-cell;} }
  @media (max-width:940px) { col.lb-3h,  th.lb-3h,  td.lb-3h {display:table-cell;} }
  @media (max-width:880px) { col.lb-1h,  th.lb-1h,  td.lb-1h {display:table-cell;} }
  @media (max-width:820px) { col.lb-30m, th.lb-30m, td.lb-30m{display:table-cell;} }

  /* Ensure base font size remains consistent on mobile */
  @media (max-width: 899px), (hover: none) and (pointer: coarse) {
    :root{ --base-font-size:12px; }
  }

  /* Mobile: hide right-side legend subsections and push periods to the right edge */
  @media (max-width: 899px), (hover: none) and (pointer: coarse) {
    #chartLegend .legend-section.granularity,
    #chartLegend .legend-section.axis {
      display: none !important;
    }
    /* Keep the token on the left and move periods to the right */
    #chartLegend .legend-section.token { justify-content: flex-start; }
    #chartLegend .legend-section.periods { justify-content: flex-end; }
  }

  /* Hide keyboard shortcut hints in the status/footer on mobile */
  @media (max-width: 899px), (hover: none) and (pointer: coarse) {
    .footer .hint { display: none !important; }
  }

  /* Strong mobile lock: prevent any page-level vertical scroll or rubber-band while
     keeping internal scroll on .screen and .table-wrap. This uses position:fixed
     to lock the document and overscroll-behavior to stop chaining. */
  @media (max-width: 899px), (hover: none) and (pointer: coarse) {
    html, body {
      height: 100vh !important;
      overflow: hidden !important;
      overscroll-behavior: none !important;
      -webkit-overflow-scrolling: auto !important;
    }
    /* Fix body to viewport to completely prevent page scroll */
    body {
      position: fixed !important;
      inset: 0 !important;
      width: 100% !important;
    }

    /* internal scrollers stay scrollable */
    .screen{ overflow:auto; -webkit-overflow-scrolling: touch; }
    .table-wrap{ overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling: touch; }

    /* selection + highlight off on touch, but keep it for form controls */
    * { -webkit-user-select: none !important; user-select: none !important; }
    ::selection { background: transparent !important; color: inherit !important; }
    input, textarea, select, button, [contenteditable="true"] {
      -webkit-user-select: text !important; user-select: text !important;
    }
  }

  /* iOS/iPadOS niceties: kill callouts and tap highlights globally, allow in inputs */
  /* kill tap highlight */
  * { -webkit-tap-highlight-color: transparent; }
  /* kill long-press callout */
  html, body, * { -webkit-touch-callout: none; }
  /* allow callout inside editors/inputs */
  input, textarea, select, button, [contenteditable="true"] { -webkit-touch-callout: default; }

  /* Context menu + bulk editor */
  .ctxmenu{ position:fixed; z-index:9999; min-width:220px;
    background:var(--surface); border:1px solid var(--border); border-radius:10px;
    box-shadow:0 10px 30px rgba(0,0,0,.35); overflow:hidden; }
  .ctxmenu .hdr{ padding:8px 12px; color:var(--muted); border-bottom:1px solid var(--border); font-weight:600; }
  .ctxmenu button{ all:unset; display:block; width:100%; padding:10px 12px; cursor:pointer; }
  .ctxmenu button:hover{ background:rgba(255,255,255,.06); }

  #ctxMenu.bulk-editor{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45); z-index:99999; padding:20px; box-sizing:border-box;
    backdrop-filter: blur(6px) saturate(1.05); -webkit-backdrop-filter: blur(6px) saturate(1.05);
  }
  body.editor-open .wrap > .card{ transition:filter .18s ease; filter:brightness(.78) saturate(.9); }

  /* Editor panel */
  #ctxMenu.bulk-editor .editor{
    display:flex;
    flex-direction:column;
    overflow:visible; /* let the inner scroller handle overflow */
    background: rgba(0,0,0,0.6);
    border-radius:12px;
    padding:12px;
    box-shadow:0 8px 30px rgba(0,0,0,0.45);
    box-sizing: border-box;
    width: auto; max-width: calc(100% - 48px);
  }

  /* Table inside editor */
  #ctxMenu.bulk-editor .editor > div[style*="overflow:auto"],
  #ctxMenu.bulk-editor .editor > .scroll {
    max-height:60vh;
    overflow:auto;
  }
  #ctxMenu.bulk-editor .editor h3{ display:none; }
  #ctxMenu.bulk-editor table.editor-table{ width:100%; table-layout:fixed; border-collapse:collapse; font-size:var(--base-font-size); font-family:inherit; }
  #ctxMenu.bulk-editor table.editor-table th, #ctxMenu.bulk-editor table.editor-table td{ padding:8px 6px; border-bottom:1px solid var(--border); }
  #ctxMenu.bulk-editor table.editor-table thead th{ padding-left:14px; padding-right:12px; }
  #ctxMenu.bulk-editor table.editor-table th.num, #ctxMenu.bulk-editor table.editor-table td.num{ text-align:right; }
  #ctxMenu.bulk-editor input.num{ text-align:right; }
  #ctxMenu.bulk-editor .editor-new-row td.add{ padding:8px; }
  #ctxMenu.bulk-editor .editorAdd{
    display:flex; align-items:center; justify-content:flex-start; width:100%; height:28px; padding:0 6px; box-sizing:border-box;
  border-radius:6px; border:1px dashed transparent; cursor:pointer; font-weight:700; font-size:calc(var(--base-font-size) + 2px);
    background:transparent; color:var(--muted);
  }
  #ctxMenu.bulk-editor .editorAdd:hover{ background:rgba(255,255,255,.02); border-color:var(--border); color:var(--fg); }
  #ctxMenu.bulk-editor .editorDel{ background:transparent; border:none; color:var(--muted); padding:6px 8px; cursor:pointer; font-size:calc(var(--base-font-size) + 2px); line-height:1; }
  #ctxMenu.bulk-editor .editorDel:hover{ color:var(--accent); }
  #ctxMenu.bulk-editor .editorDelWrap{
    display:flex; align-items:center; justify-content:flex-end; width:100%; height:28px; padding:0 6px; box-sizing:border-box; background:transparent; border-radius:6px; border:1px solid transparent;
  }
  #ctxMenu.bulk-editor .editorDelWrap:hover{ background:rgba(255,255,255,.02); border-color:var(--border); }
  #ctxMenu.bulk-editor .editorDelWrap:focus{ outline:none; box-shadow:0 0 0 3px rgba(92,168,255,.08); border-color:var(--accent-2); }

  /* Clean, single definitions */
  #ctxMenu.bulk-editor .editor-footer{
    display:flex;
    justify-content:flex-end;
    align-items:center;
    gap:12px;
    margin-top:8px;
  }
  #ctxMenu.bulk-editor .btns{
    display:flex;
    gap:8px;
    justify-content:flex-end;
    align-items:center;
    margin:0;
  }
  #ctxMenu.bulk-editor input[type=text], #ctxMenu.bulk-editor input[type=number]{
    width:100%; background:transparent; border:none; color:var(--fg);
    padding:0 6px; border-radius:0; font-family:inherit; font-size:var(--base-font-size); font-variant-numeric:tabular-nums;
    height:28px; box-sizing:border-box;
  }
  #ctxMenu.bulk-editor table.editor-table input{ background:transparent; border:none; padding:0 6px; }
  #ctxMenu.bulk-editor table.editor-table input:focus{ outline:1px dashed rgba(255,255,255,.06); }
  #ctxMenu.bulk-editor .btn{
    background:rgba(255,255,255,.04); border:1px solid var(--border); padding:6px 10px; border-radius:8px; cursor:pointer; color:var(--fg); font-family:inherit; font-size:var(--base-font-size);
  }
</style>
<script id="touch-alias-script">(function(){
  // Add .touch to <html> on iPadOS and similar devices that support touch but
  // may report a fine pointer/hover (so media queries miss them).
  try{
    var isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    // iPadOS 13+ and some tablets report a Mac-like pointer; detect by presence of touch + platform
    var isiPadLike = isTouch && /Mac|iPad|iPhone/.test(navigator.platform || navigator.userAgent);
    if(isiPadLike){ document.documentElement.classList.add('touch'); }
  }catch(e){}
})();</script>
<style id="touch-alias-css">
/* Alias the mobile media-query rules when .touch is present on <html> */
html.touch { --base-font-size: 12px; }
html.touch .footer .hint { display: none !important; }

/* Strong mobile lock alias for html.touch to mirror the media-query lock */
html.touch, html.touch body {
  height: 100vh !important;
  overflow: hidden !important;
  overscroll-behavior: none !important;
  -webkit-overflow-scrolling: auto !important;
}
html.touch body {
  position: fixed !important;
  inset: 0 !important;
  width: 100% !important;
}
html.touch .screen,
html.touch .table-wrap { overflow: auto; -webkit-overflow-scrolling: touch; }

/* Disable selection and tap highlights on touch alias while allowing form controls */
html.touch * { -webkit-user-select: none !important; user-select: none !important; -webkit-touch-callout: none !important; -webkit-tap-highlight-color: transparent !important; }
html.touch input, html.touch textarea, html.touch select, html.touch [contenteditable] { -webkit-user-select: text !important; user-select: text !important; -webkit-touch-callout: default !important; -webkit-tap-highlight-color: initial !important; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="screen">
        <!-- TABLE -->
        <div class="panel panel-table">
          <div class="table-wrap">
            <table class="data">
              <colgroup>
                <col class="c-coin" />
                <col class="c-price" />
                <col class="c-last" />
                <col class="c-avg" />
                <col class="c-ret group-sep" />
                <col class="c-liq" />
                <col class="c-buf group-sep" />
                <!-- Lookbacks injected dynamically -->
              </colgroup>
              <thead id="thead"></thead>
              <tbody id="tbody">
                <tr><td class="coin">Loading…</td><td class="muted" colspan="99">Connecting to Hyperliquid…</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- CHART -->
    <div class="panel panel-chart" id="panelChart" style="position:relative;">
    <div class="chart-head">
            <!-- Legend split into 4 even subsections: token | periods/span | granularity | date/time axis -->
            <div id="chartLegend" class="muted">
              <div class="legend-section token" id="chartToken">BTC</div>
              <div class="legend-section periods" id="chartPeriods">—</div>
              <div class="legend-section granularity" id="chartGranularity">—</div>
              <div class="legend-section axis" id="chartAxis">—</div>
            </div>
          </div>
          <canvas id="chart" width="800" height="300"></canvas>
          <!-- Overlay canvas kept for other debug drawings -->
          <canvas id="chartOverlay" width="800" height="300" style="position:absolute; inset:0; width:100%; height:100%; pointer-events:none;"></canvas>
          <!-- DOM vertical guide for hover (positioned using cached canvas coords to avoid raster alignment issues) -->
          <div id="chartGuide" aria-hidden="true"></div>
          <!-- Tooltip for chart hover -->
          <div id="chartTooltip" role="status" aria-hidden="true" style="display:none"></div>
          <div class="loading-overlay" aria-hidden="true">
            <div class="spinner" role="img" aria-hidden="true"></div>
            <div class="label">Loading chart…</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Fixed footer (pinned to viewport, shares gutters with main container) -->
  <div class="footer" aria-hidden="false">
    <div class="inner">
      <div id="clock">—</div>
      <div class="hint">
  <span id="hintSwitch"><span class="kbd">↑/↓</span> switch coin</span>
  <span><span class="kbd">←/→</span> change period</span>
        <span><span class="kbd">c</span> show/hide chart</span>
  <span><span class="kbd">v</span> toggle line/candle</span>
  <span><span class="kbd">e</span> edit coins</span>
  <span><span class="kbd">t</span> toggle light/dark</span>
      </div>
    </div>
  </div>

  <!-- Right-click context menu -->
  <div id="ctxMenu" class="ctxmenu" style="display:none"></div>

<script>
(() => {
  "use strict";

  /* ---------- CONFIG ---------- */
  const LOWPOWER = true;
  const DPR_MAX = Math.min(2, window.devicePixelRatio || 1);
  const RENDER_MIN_INTERVAL = LOWPOWER ? 250 : 150;

  const WS_URL = "wss://api.hyperliquid.xyz/ws";
  const INFO_URL = "https://api.hyperliquid.xyz/info";

  let SYMBOLS = ["BTC","ETH","SOL","HYPE"];

  // Chart lookbacks: smallest span is 1h (30m removed for chart view)
  const LOOKBACKS_CHART = [
    ["1h",60*60],["3h",3*60*60],["24h",24*60*60],["7d",7*24*60*60],["30d",30*24*60*60],
  ];

  // Table lookbacks: include finer-grained 5m and 30m for the table widget
  const LOOKBACKS_TABLE = [
    ["5m",5*60],["30m",30*60],["1h",60*60],["3h",3*60*60],["24h",24*60*60],["7d",7*24*60*60],["30d",30*24*60*60],
  ];

  // Unified intervals used for both line sampling and candle rendering.
  // Include mapping for 5m (used by the table) as well as other lookbacks.
  const INTERVAL_FOR_LOOKBACK = {"5m":"1m","30m":"1m","1h":"1m","3h":"5m","24h":"1h","7d":"4h","30d":"1d"};

  const BASELINE_REFRESH_SECONDS = LOWPOWER ? 120 : 60;
  const USE_BASELINE_INTERPOLATION = false;

  const SHOW_MY_AVG = true;
  let MY_AVG_PRICE = {"ETH":3504.97,"SOL":186.44,"HYPE":43.795};
  const MY_AVG_FORMAT = null;

  const SHOW_LIQ = true;
  let MY_LIQ_PRICE = {"HYPE":34.629};
  const BUF_COLORIZE = false;

  const SHOW_TIMESTAMP = true;
  const STRIP_LEADING_ZERO = true;

  let SHOW_CHART = true;
  const CHART_INTERVAL = "1m";
  // Chart display mode: 'line' or 'candle'
  let CHART_MODE = 'candle';
  // When in candle mode, use 1 hour candles (24h window -> 24 candles)
  const CHART_CANDLE_INTERVAL = '1h';
  // Selected lookback index into chart lookbacks (default to 24h)
  let CHART_LOOKBACK_IDX = Math.max(0, LOOKBACKS_CHART.findIndex(x=>x[0]==='24h'));
  const CHART_REFRESH_SECONDS = 30;

  const DEFAULT_NUM_FORMAT = ",.2f";
  let SYMBOL_FORMAT = {"BTC":",.0f","ETH":",.2f","SOL":".2f","HYPE":".3f"};

  /* ---------- Persistence (localStorage) ---------- */
  const STORAGE_KEY = 'hype_dashboard:user';
  let THEME = 'dark'; // 'dark' | 'light'
  function loadPersisted(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(obj.symbols && Array.isArray(obj.symbols) && obj.symbols.length) SYMBOLS = obj.symbols.slice();
      if(obj.avg && typeof obj.avg === 'object') Object.assign(MY_AVG_PRICE, obj.avg);
      if(obj.liq && typeof obj.liq === 'object') Object.assign(MY_LIQ_PRICE, obj.liq);
      if(obj.fmt && typeof obj.fmt === 'object') Object.assign(SYMBOL_FORMAT, obj.fmt);
    if(obj.chartMode && (obj.chartMode === 'line' || obj.chartMode === 'candle')) CHART_MODE = obj.chartMode;
    if(obj.theme && (obj.theme === 'light' || obj.theme === 'dark')) THEME = obj.theme;
  if(typeof obj.chartLookbackIdx === 'number') CHART_LOOKBACK_IDX = Math.max(0, Math.min(LOOKBACKS_CHART.length-1, obj.chartLookbackIdx));
    }catch(e){ console.debug('loadPersisted failed', e); }
  }
  function savePersisted(){
    try{
  const payload = { symbols: SYMBOLS, avg: MY_AVG_PRICE, liq: MY_LIQ_PRICE, fmt: SYMBOL_FORMAT, chartMode: CHART_MODE, chartLookbackIdx: CHART_LOOKBACK_IDX, theme: THEME };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }catch(e){ console.debug('savePersisted failed', e); }
  }
  function applyTheme(){
    document.body.classList.toggle('light', THEME === 'light');
  }

  // Defensive: ensure CHART_LOOKBACK_IDX is always valid against the current LOOKBACKS_CHART
  function ensureChartIdx(){
    if(!Array.isArray(LOOKBACKS_CHART) || LOOKBACKS_CHART.length===0){ CHART_LOOKBACK_IDX = 0; return; }
    if(typeof CHART_LOOKBACK_IDX !== 'number' || !Number.isFinite(CHART_LOOKBACK_IDX)) CHART_LOOKBACK_IDX = 0;
    CHART_LOOKBACK_IDX = Math.max(0, Math.min(LOOKBACKS_CHART.length - 1, CHART_LOOKBACK_IDX));
  }

  const HEARTBEAT_SECONDS = 30;
  const RECONNECT_DELAY_MS = 3000;
  const HTTP_TIMEOUT_MS = 10000;

  // Keep console quiet in prod
  const AXIS_DEBUG = false;

  const DELTA_FLASH_ENABLED = true;
  const DELTA_FLASH_MS = 280;

  /* ---------- STATE ---------- */
  const latest_mid = Object.fromEntries(SYMBOLS.map(s=>[s,null]));
  const baselines  = Object.fromEntries(SYMBOLS.map(s=>[s,{}]));
  const last_mid_ts= Object.fromEntries(SYMBOLS.map(s=>[s,null]));
  const chart_series = Object.fromEntries(SYMBOLS.map(s=>[s,[]]));
  const chart_times  = Object.fromEntries(SYMBOLS.map(s=>[s,[]]));
  const chart_candles = Object.fromEntries(SYMBOLS.map(s=>[s,[]]));
  const hasSnapshot  = Object.fromEntries(SYMBOLS.map(s=>[s,false]));
  const pendingLive  = Object.fromEntries(SYMBOLS.map(s=>[s,null]));
  const _last_price_value = Object.fromEntries(SYMBOLS.map(s=>[s,null]));
  const _flash_until = Object.fromEntries(SYMBOLS.map(s=>[s,0]));
  const _flash_dir   = Object.fromEntries(SYMBOLS.map(s=>[s,0]));

  let _selected_idx = 0, _last_render_time = 0, _changed = true;
  let _hydrated = false;
  let _lastRowPickAt = 0;
  // Track last rendered periods index to avoid rebuilding the periods DOM on every draw
  let LAST_CHART_PERIODS_IDX = null;

  /* ---------- ELEMENTS ---------- */
  const theadEl = document.getElementById("thead");
  const tbodyEl = document.getElementById("tbody");
  const clockEl = document.getElementById("clock");
  const panelChart = document.getElementById("panelChart");
  const chartAxis  = document.getElementById("chartAxis");
  const chart      = document.getElementById("chart");
  const hintSwitch = document.getElementById("hintSwitch");
  const ctx = chart.getContext("2d");
  const overlay = document.getElementById('chartOverlay');
  const overlayCtx = overlay ? overlay.getContext('2d') : null;
  // Debug toggle: press 'd' to toggle visual debug markers on the overlay
  let CHART_DEBUG = false;

  // Overlay helpers for immediate UI feedback when changing periods/mode
  function getChartOverlay(){ return document.querySelector('.panel-chart .loading-overlay'); }
  function showChartOverlayInstant(){ const o=getChartOverlay(); if(o) o.classList.add('visible'); }
  function hideChartOverlay(){ const o=getChartOverlay(); if(o) o.classList.remove('visible'); }

  /* ---------- UTIL ---------- */
  const nowMs = ()=>Date.now();
  function fmtClock(){
    const d=new Date(); let h=d.getHours();
    const m=String(d.getMinutes()).padStart(2,"0"), s=String(d.getSeconds()).padStart(2,"0");
    const ampm=h>=12?"PM":"AM"; h=h%12; if(h===0)h=12;
    let hh=String(h).padStart(2,"0"); if(STRIP_LEADING_ZERO) hh=String(h);
    return `${hh}:${m}:${s} ${ampm}`;
  }
  function fmtTs(ms, { seconds=false, showDate=false } = {}){
    const d = new Date(ms);
    let h = d.getHours();
    const m = String(d.getMinutes()).padStart(2,"0");
    const s = String(d.getSeconds()).padStart(2,"0");
    const ampm = h >= 12 ? "PM" : "AM";
    h = h % 12; if(h === 0) h = 12;
    let hh = STRIP_LEADING_ZERO ? String(h) : String(h).padStart(2,"0");
    const t = seconds ? `${hh}:${m}:${s} ${ampm}` : `${hh}:${m} ${ampm}`;
  if(!showDate) return t;
  const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
  const md = `${monthNames[d.getMonth()]} ${d.getDate()}`;
  return `${md} ${t}`;
  }
  function fmtAgeMs(ms){
    if(ms==null) return "—"; let delta=nowMs()-ms; if(delta<0) delta=0;
    const s=Math.floor(delta/1000); if(s<60) return `${s}s`;
    const m=Math.floor(s/60); if(m<60) return `${m}m`;
    return `${Math.floor(m/60)}h`;
  }
  function formatWithSpec(v,spec){
    if(v==null||Number.isNaN(v))return "";
    const useComma=spec?.includes(","); let dec=0; const dot=spec?.indexOf(".");
    if(dot>=0){const tail=spec.slice(dot+1); const m=tail.match(/^(\d+)/); if(m) dec=parseInt(m[1],10);}
    const opts={minimumFractionDigits:dec, maximumFractionDigits:dec};
    return useComma?Number(v).toLocaleString(undefined,opts):Number(v).toFixed(dec);
  }
  const fmtMid=(sym,v)=>v==null?"":formatWithSpec(v, SYMBOL_FORMAT[sym]??DEFAULT_NUM_FORMAT);
  const fmtAvg=(sym,avg)=>avg==null?"—":formatWithSpec(avg, (MY_AVG_FORMAT||SYMBOL_FORMAT[sym]||DEFAULT_NUM_FORMAT));
  const pctChange=(nv,ov)=> (nv==null||ov==null||ov===0) ? null : (nv-ov)/ov*100;

  // Epoch helper
  const MS_EPOCH_CUTOFF = 1e12;
  const toMs = (t) => (t < MS_EPOCH_CUTOFF ? t * 1000 : t);

  /* ---------- AXIS (live-to-now window) ---------- */
  function computeAxisRange(){
  ensureChartIdx();
  const now = nowMs();
  const lb = LOOKBACKS_CHART[CHART_LOOKBACK_IDX] || LOOKBACKS_CHART[0];
  const windowMs = (lb ? lb[1] : 24*60*60) * 1000;
  return [now - windowMs, now];
  }
  function renderAxis(){
    const [L, R] = computeAxisRange();
  chartAxis.textContent = `${fmtTs(L, { showDate: true })}  —  ${fmtTs(R, { showDate: true })}`;
  }

  /* ---------- TABLE ---------- */
  function buildTableHeader(){
    const colgroup = document.querySelector('table.data colgroup');
  const lbCols = LOOKBACKS_TABLE.map(([lb])=>`<col class="c-lb lb-${lb}" />`).join("");
    colgroup.insertAdjacentHTML("beforeend", lbCols);

  const lookbackTh = LOOKBACKS_TABLE.map(([lb],i)=>`<th class="num lb-${lb} ${i===0?'group-sep':''}">${lb}</th>`).join("");
    theadEl.innerHTML = `
      <tr>
        <th class="h-coin">COIN</th>
        <th class="num h-price">PRICE</th>
        <th class="num h-last">LAST</th>
        <th class="num h-avg">AVG</th>
        <th class="num h-ret">RET%</th>
        <th class="num h-liq">LIQ</th>
        <th class="num h-buf">BUF%</th>
        ${lookbackTh}
      </tr>`;
    try{ updateColumnWidths(); }catch(e){}
  }

  /* Uniform column sizing: min 14ch incl padding, grow equally */
  function updateColumnWidths(){
    const table = document.querySelector('table.data');
    if(!table) return;

    // visible columns
    const ths = Array.from(table.querySelectorAll('thead th')).filter(th=>{
      const cs = getComputedStyle(th);
      return cs.display !== 'none';
    });
    const n = ths.length || 1;

    // wrapper width we can use
    const wrap = table.closest('.table-wrap') || table.parentElement || document.body;
    const wrapW = Math.max(0, wrap.clientWidth || 0);

    // measure 14ch in the table’s font
    let ch14 = 0;
    try{
      const probe = document.createElement('span');
      probe.style.position='absolute';
      probe.style.visibility='hidden';
      probe.style.whiteSpace='nowrap';
      probe.style.font = getComputedStyle(table).font;
  probe.textContent = '0'.repeat(10);
      document.body.appendChild(probe);
      ch14 = Math.ceil(probe.getBoundingClientRect().width);
      document.body.removeChild(probe);
    }catch(e){ ch14 = 120; } // fallback

    const cellHPad = 16; // td/th padding-left+right (8+8)
    const minColPx = ch14 + cellHPad;

    // equal width across all columns, but never below our min
    const equalColPx = Math.floor(wrapW / n);
    const colPx = Math.max(minColPx, equalColPx);

    table.style.setProperty('--colw', colPx + 'px');
    table.style.minWidth = Math.ceil(minColPx * n) + 'px';
    table.style.width = '100%';
  }

  function hydrateTable(){
    const rows = SYMBOLS.map(sym=>{
  const lbTds = LOOKBACKS_TABLE.map(([lb],i)=>`<td class="num lb-${lb} ${i===0?'group-sep':''}">—</td>`).join("");
      return `
        <tr data-sym="${sym}">
          <td class="coin"><span class="sel-dot"></span><span>${sym}</span></td>
          <td class="num c-price"></td>
          <td class="num c-last muted">—</td>
          <td class="num c-avg">—</td>
          <td class="num c-ret">—</td>
          <td class="num c-liq">—</td>
          <td class="num c-buf">—</td>
          ${lbTds}
        </tr>`;
    }).join("");
    tbodyEl.innerHTML = rows;
    _hydrated = true;
    updateSelectionDots();
    try{ updateColumnWidths(); }catch(e){}
    // Attach long-press handlers to the freshly created rows
    attachLongPressHandlers();
  }

  /* ---------- LONG-PRESS (mobile) ---------- */
  function attachLongPressHandlers(){
    const LONGPRESS_MS = 520;
    const MOVE_TOLERANCE = 10; // px

    // Clean up any previous handlers first by replacing nodes (cheap for small table)
    const rows = Array.from(tbodyEl.querySelectorAll('tr[data-sym]'));
    rows.forEach(row=>{
      // remove any existing data handlers
      row._lp = row._lp || {};
      // pointer state
      let timer = null, startX = 0, startY = 0, pointed = false;

      function start(e){
        // Only enable long-press on touch/pen devices or when viewport is mobile-sized
        const isMouse = e.pointerType === 'mouse';
        const isMobileViewport = window.matchMedia('(max-width: 899px)').matches;
        if(isMouse && !isMobileViewport) return;
        pointed = true; startX = e.clientX; startY = e.clientY;
        timer = setTimeout(()=>{
          // open context menu for this coin; hide header and bulk formats on long-press
          const sym = row.getAttribute('data-sym');
          if(sym){
            try{ openContextMenu({ clientX: startX, clientY: startY }, sym, { noHeader: true, hideFormats: true }); }catch(e){}
          }
          timer = null;
        }, LONGPRESS_MS);
      }

      function move(e){ if(!pointed) return; if(Math.hypot(e.clientX - startX, e.clientY - startY) > MOVE_TOLERANCE) cancel(); }
      function end(){ cancel(); pointed = false; }
      function cancel(){ if(timer){ clearTimeout(timer); timer = null; } }

      // Remove previous listeners if present
      if(row._lp.cleanup){ try{ row._lp.cleanup(); }catch(e){} }

      row.addEventListener('pointerdown', start, {passive:true});
      row.addEventListener('pointermove', move, {passive:true});
      row.addEventListener('pointerup', end, {passive:true});
      row.addEventListener('pointercancel', end, {passive:true});

      // store cleanup to remove listeners later if needed
      row._lp.cleanup = ()=>{
        try{ row.removeEventListener('pointerdown', start); row.removeEventListener('pointermove', move); row.removeEventListener('pointerup', end); row.removeEventListener('pointercancel', end); }catch(e){}
      };
    });
  }

  function updateSelectionDots(){
    const trs = tbodyEl.querySelectorAll("tr[data-sym]");
    trs.forEach(tr=>{
      const sym = tr.getAttribute("data-sym");
      tr.classList.toggle("row-selected", SHOW_CHART && sym === SYMBOLS[_selected_idx]);
    });
  }

  function updateRow(sym){
    const tr = tbodyEl.querySelector(`tr[data-sym="${sym}"]`);
    if(!tr) return;

    const mid = latest_mid[sym];
    const last= last_mid_ts[sym];
    const avg = MY_AVG_PRICE[sym];
    const ret = pctChange(mid,(avg!=null && avg!==0)?avg:null);
    const liq = MY_LIQ_PRICE[sym];
    const liqTxt = (liq!=null)? formatWithSpec(liq, SYMBOL_FORMAT[sym]||DEFAULT_NUM_FORMAT) : "—";
    let bufPct=null; if(mid!=null && mid!==0 && liq!=null){ bufPct=(mid-liq)/mid*100.0; }

    const priceTd = tr.querySelector("td.c-price");
    const prev = _last_price_value[sym];
    if(DELTA_FLASH_ENABLED && prev!=null && mid!=null){
      const dir = mid>prev?1:(mid<prev?-1:0);
      if(dir!==0){ _flash_dir[sym]=dir; _flash_until[sym]=nowMs()+DELTA_FLASH_MS; }
    }
    _last_price_value[sym]=mid;
    priceTd.textContent = fmtMid(sym, mid);
    priceTd.classList.remove("flash-up","flash-down");
    if(_flash_until[sym] > nowMs()){
      priceTd.classList.add(_flash_dir[sym]>0 ? "flash-up" : (_flash_dir[sym]<0 ? "flash-down" : ""));
    }

    const lastTd = tr.querySelector("td.c-last");
    if(lastTd) lastTd.textContent = fmtAgeMs(last);

    const avgTd  = tr.querySelector("td.c-avg"); if(avgTd) avgTd.textContent = fmtAvg(sym, avg);
    const retTd  = tr.querySelector("td.c-ret");
    if(retTd){
      retTd.textContent = "—";
      retTd.classList.remove("pos","neg");
      if(ret!=null){ retTd.textContent = ret.toFixed(2)+"%"; retTd.classList.add(ret>=0?"pos":"neg"); }
    }
    const liqTd  = tr.querySelector("td.c-liq"); if(liqTd) liqTd.textContent = liqTxt;
    const bufTd  = tr.querySelector("td.c-buf");
    if(bufTd){
      bufTd.textContent = "—";
      bufTd.classList.remove("pos","neg");
      if(bufPct!=null){
        bufTd.textContent = bufPct.toFixed(2)+"%";
        if(BUF_COLORIZE) bufTd.classList.add(bufPct>=0?"pos":"neg");
      }
    }

  for(const [lb,] of LOOKBACKS_TABLE){
      const td = tr.querySelector(`td.lb-${lb}`);
      if(!td) continue;
      const base = baselines[sym][lb];
      const p = pctChange(mid, base);
      td.textContent = "—";
      td.classList.remove("pos","neg");
      if(p!=null){ td.textContent = p.toFixed(2)+"%"; td.classList.add(p>=0?"pos":"neg"); }
    }
  }

  function updateTable(){
    if(!_hydrated){ hydrateTable(); }
    updateSelectionDots();
    SYMBOLS.forEach(updateRow);
  }

  tbodyEl?.addEventListener("click", (e)=>{
    const now = performance.now();
    if (now - _lastRowPickAt < 250) return;
    _lastRowPickAt = now;

    const tr = e.target.closest("tr[data-sym]");
    if(!tr) return;
    const idx = SYMBOLS.indexOf(tr.getAttribute("data-sym"));
    if(idx>=0 && idx !== _selected_idx){
      _selected_idx = idx;
      updateSelectionDots();
      drawChart();
    }
  });

  /* ---------- CONTEXT MENU / BULK EDITOR ---------- */
  function clampToCanvas(x, y, menuEl){
    const pad = 8;
    const vw = window.innerWidth, vh = window.innerHeight;
    const r = { w: menuEl.offsetWidth || 220, h: menuEl.offsetHeight || 140 };
    const nx = Math.min(Math.max(pad, x), vw - r.w - pad);
    const ny = Math.min(Math.max(pad, y), vh - r.h - pad);
    return {x:nx, y:ny};
  }
  function closeCtx(){
    const m=document.getElementById('ctxMenu'); if(!m) return;
  try{ if(m.__overlayClickHandler){ m.removeEventListener('click', m.__overlayClickHandler); delete m.__overlayClickHandler; } }catch(e){}
  m.style.display='none'; m.innerHTML=''; m.className = 'ctxmenu';
  m.style.position=''; m.style.left=''; m.style.top=''; m.style.transform=''; m.style.width='';
  m.onclick = null;
  document.body.classList.remove('editor-open');
  document.removeEventListener('click', closeCtx, {capture:true});
  }
  function promptNumber(label, initial){
    const v = prompt(label, initial ?? '');
    if(v==null) return null;
    const n = Number(String(v).replace(/[_ ,]/g,'')); 
    return Number.isFinite(n) ? n : null;
  }
  function promptFormat(label, initial){
    const v = prompt(label + " (examples: ',.0f', ',.2f', '.3f')", initial ?? '');
    if(v==null) return null;
    return v.trim() || null;
  }
  function rebuildStoresForSymbols(){
    const makeObj = (fill=null)=>Object.fromEntries(SYMBOLS.map(s=>[s,fill]));
    for(const k of Object.keys(latest_mid)) delete latest_mid[k];
    for(const k of Object.keys(baselines))  delete baselines[k];
    for(const k of Object.keys(last_mid_ts))delete last_mid_ts[k];
    for(const k of Object.keys(chart_series))delete chart_series[k];
    for(const k of Object.keys(chart_times)) delete chart_times[k];
    for(const k of Object.keys(_last_price_value)) delete _last_price_value[k];
    for(const k of Object.keys(_flash_until)) delete _flash_until[k];
    for(const k of Object.keys(_flash_dir))   delete _flash_dir[k];

    Object.assign(latest_mid, makeObj(null));
    Object.assign(baselines,  Object.fromEntries(SYMBOLS.map(s=>[s,{}])));
    Object.assign(last_mid_ts,makeObj(null));
    Object.assign(chart_series,makeObj([]));
    Object.assign(chart_times, makeObj([]));
    Object.assign(_last_price_value, makeObj(null));
    Object.assign(_flash_until, makeObj(0));
    Object.assign(_flash_dir,   makeObj(0));

    SYMBOLS.forEach(s=>{
      if(!(s in MY_AVG_PRICE))  MY_AVG_PRICE[s]=null;
      if(!(s in MY_LIQ_PRICE))  MY_LIQ_PRICE[s]=null;
      if(!(s in SYMBOL_FORMAT)) SYMBOL_FORMAT[s]=DEFAULT_NUM_FORMAT;
    });

    _hydrated=false;
    hydrateTable();
    updateTable();
    try{ updateColumnWidths(); }catch{}
    _selected_idx = 0;
    updateSelectionDots();
    drawChart();

    refreshAllBaselines().catch(()=>{});
    if(SHOW_CHART) refreshAllCharts().catch(()=>{});
  }
  function openContextMenu(e, sym){
    const menu = document.getElementById('ctxMenu');
    if(!menu) return;
    // allow callers to customize menu rendering (e.g. hide header or formats for long-press)
    const opts = (arguments.length >= 3 && typeof arguments[2] === 'object') ? arguments[2] : {};

    const headerHtml = opts.noHeader ? '' : `<div class="hdr">${sym ? 'Coin: '+sym : 'Dashboard'}</div>`;
    const symButtons = sym ? `
        <button data-act="avg">Edit AVG For ${sym}</button>
        <button data-act="liq">Edit LIQ For ${sym}</button>
        <button data-act="fmt">Set Price Format For ${sym}</button>
        <hr style="border:none;border-top:1px solid var(--border);margin:6px 0;">
      ` : '';
    const formatsHtml = opts.hideFormats ? '' : `<button data-act="formats">Global Set Formats…</button>`;

    menu.innerHTML = `${headerHtml}${symButtons}<button data-act="list">Edit Coin List</button>
      <button data-act="restore">Restore To Defaults</button>
      ${formatsHtml}`;
    menu.style.display='block';
    document.body.classList.add('editor-open');
    const pos = clampToCanvas(e.clientX, e.clientY, menu);
    menu.style.left = pos.x + 'px';
    menu.style.top  = pos.y + 'px';
    // Install a capture-phase click handler that only closes the menu when the
    // click is outside the menu. This avoids closing the menu before menu
    // button handlers run on touch devices (capture runs before target handlers).
    const overlayHandler = function overlayHandler(ev){
      try{
        // if click is inside the menu, re-install the outside-click listener for next time
        if(menu.contains(ev.target)){
          // re-arm for the next click outside
          setTimeout(()=>document.addEventListener('click', overlayHandler, {capture:true, once:true}), 0);
          return;
        }
      }catch(e){}
      // else it's outside - close
      try{ closeCtx(); }catch(e){}
    };
    // store so closeCtx can remove if needed
    menu.__overlayClickHandler = overlayHandler;
    setTimeout(()=>document.addEventListener('click', overlayHandler, {capture:true, once:true}), 0);

    menu.onclick = (ev)=>{
      const a = ev.target.closest('button')?.dataset?.act;
      if(!a) return;
      if(a==='avg' && sym){
        const cur = MY_AVG_PRICE[sym] ?? '';
        const n = promptNumber(`Enter AVG for ${sym}`, cur);
        if(n!=null){ MY_AVG_PRICE[sym]=n; updateRow(sym); }
        try{ savePersisted(); }catch(e){}
      }else if(a==='liq' && sym){
        const cur = MY_LIQ_PRICE[sym] ?? '';
        const n = promptNumber(`Enter LIQ for ${sym}`, cur);
        if(n!=null){ MY_LIQ_PRICE[sym]=n; updateRow(sym); }
        try{ savePersisted(); }catch(e){}
      }else if(a==='fmt' && sym){
        const cur = SYMBOL_FORMAT[sym] ?? DEFAULT_NUM_FORMAT;
        const f = promptFormat(`Format for ${sym}`, cur);
        if(f){ SYMBOL_FORMAT[sym]=f; updateRow(sym); drawChart(); }
        try{ savePersisted(); }catch(e){}
  }else if(a==='list'){
        const cur = SYMBOLS.join(',');
        const v = prompt("Comma-separated symbols (e.g. BTC,ETH,SOL,HYPE)", cur);
        if(v!=null){
          const next = Array.from(new Set(String(v).split(/[,\s]+/).map(s=>s.trim().toUpperCase()).filter(Boolean)));
          if(next.length){
            SYMBOLS = next;
            rebuildStoresForSymbols();
            try{ savePersisted(); }catch(e){}
          }
        }
      }else if(a==='formats'){
        const msg = "Bulk format (applies to all listed coins).\nExamples: ',.0f', ',.2f', '.3f'";
        const f = prompt(msg, DEFAULT_NUM_FORMAT);
        if(f){
          SYMBOLS.forEach(s=>SYMBOL_FORMAT[s]=f);
          updateTable(); drawChart();
          try{ savePersisted(); }catch(e){}
        }
      }else if(a==='restore'){
        const ok = confirm('Restore defaults? This will clear saved symbols, averages, liqs and formats and reload the page. Continue?');
        if(ok){ try{ localStorage.removeItem(STORAGE_KEY); location.reload(); }catch(e){} }
      }
      closeCtx();
    };
  }

  /* ---------- BULK EDITOR (synced state) ---------- */
  let _editorOpen = false;

  function openBulkEditor(){
    _editorOpen = true;
    const menu = document.getElementById('ctxMenu');
    menu.className = 'ctxmenu bulk-editor';
    menu.innerHTML = `
      <div class="editor" role="dialog" aria-modal="true">
        <div style="overflow:auto;">
          <table class="editor-table">
            <colgroup>
              <col class="c-coin" />
              <col class="c-avg" />
              <col class="c-liq" />
              <col class="c-fmt" />
              <col class="c-del" />
            </colgroup>
            <thead>
              <tr>
                <th>COIN</th>
                <th class="num">AVG</th>
                <th class="num">LIQ</th>
                <th class="num">FORMAT</th>
                <th class="num">DEL</th>
              </tr>
            </thead>
            <tbody id="editorBody"></tbody>
          </table>
        </div>
        <div class="editor-footer">
          <div class="btns">
            <button id="editorReset" class="btn">Defaults</button>
            <button id="editorCancel" class="btn">Cancel</button>
            <button id="editorSave" class="btn">Save</button>
          </div>
        </div>
      </div>`;

    const body = document.getElementById('editorBody');
    function renderRows(){
      body.innerHTML = '';
      SYMBOLS.forEach((s,idx)=>{
        const tr = document.createElement('tr');
        const avgVal = MY_AVG_PRICE[s] != null ? Number(MY_AVG_PRICE[s]).toLocaleString() : '';
        const liqVal = MY_LIQ_PRICE[s] != null ? Number(MY_LIQ_PRICE[s]).toLocaleString() : '';
        const isNew = (s === 'NEW');
        tr.innerHTML = `
          <td><input class="sym" data-idx="${idx}" data-field="sym" type="text" value="${isNew? '': s}" placeholder="${isNew? 'NEW COIN': ''}" /></td>
          <td class="num"><input class="num" data-idx="${idx}" data-field="avg" type="text" value="${avgVal}" /></td>
          <td class="num"><input class="num" data-idx="${idx}" data-field="liq" type="text" value="${liqVal}" /></td>
          <td class="num"><input class="num" data-idx="${idx}" data-field="fmt" type="text" value="${SYMBOL_FORMAT[s] ?? ''}" /></td>
          <td class="num">
            <div class="editorDelWrap" data-idx="${idx}" role="button" tabindex="0" title="Delete">
              <button data-idx="${idx}" class="editorDel" title="Delete">×</button>
            </div>
          </td>`;
        body.appendChild(tr);
      });
      const addTr = document.createElement('tr'); addTr.className = 'editor-new-row';
      const nextIdx = SYMBOLS.length;
      addTr.innerHTML = `
        <td class="add"><div id="editorAddRow" class="editorAdd" role="button" tabindex="0" title="Add">+</div></td>
        <td class="num"><input class="num" data-idx="${nextIdx}" data-field="avg" type="text" value="" /></td>
        <td class="num"><input class="num" data-idx="${nextIdx}" data-field="liq" type="text" value="" /></td>
        <td class="num"><input class="num" data-idx="${nextIdx}" data-field="fmt" type="text" value="" /></td>
        <td class="num"></td>`;
      body.appendChild(addTr);
    }
    renderRows();

    function adjustEditorColumnWidths(){
      try{
        const menu = document.getElementById('ctxMenu');
        if(!menu) return;
        const edTable = menu.querySelector('table.editor-table');
        if(!edTable) return;

        // helper to get main table header width by selector
        const headerWidth = (sel)=>{
          const th = document.querySelector(sel);
          if(!th) return null;
          return Math.max(0, Math.round(th.getBoundingClientRect().width));
        };

        const mapping = {
          'c-coin': '.h-coin',
          'c-avg' : '.h-avg',
          'c-liq' : '.h-liq',
          'c-fmt' : null,
          'c-del' : null,
        };

        const cols = edTable.querySelectorAll('col');
        cols.forEach(col=>{
          const cls = (col.className||'').split(/\s+/).find(c=>c.startsWith('c-'));
          if(!cls) return;
          const sel = mapping[cls];
          if(sel){ const w = headerWidth(sel); if(w) col.style.width = w + 'px'; else col.style.width = ''; }
          else{
            if(cls==='c-fmt') col.style.width = '124px';
            else if(cls==='c-del') col.style.width = '88px';
            else col.style.width = '';
          }
        });
      }catch(e){}
    }

    menu.style.display='block';
    menu.focus?.();
    try{
      if(menu.parentElement !== document.body) document.body.appendChild(menu);
      // clear any leftover inline positioning left from context menus
      menu.style.left = '';
      menu.style.top = '';
      menu.style.right = '';
      menu.style.bottom = '';
      menu.style.transform = '';
      menu.style.width = '';
      // center as a full-viewport fixed overlay
      menu.style.position = 'fixed';
      menu.style.inset = '0';
      menu.style.display = 'flex';
      menu.style.alignItems = 'center';
      menu.style.justifyContent = 'center';
      const wrapEl = document.querySelector('.wrap');
      if(wrapEl){
        const r = wrapEl.getBoundingClientRect();
        const maxW = Math.min(920, Math.max(320, Math.floor(r.width - 40)));
        const ed = menu.querySelector('.editor');
        if(ed){
          ed.style.maxWidth = maxW + 'px';
          ed.style.width = 'auto';
          ed.style.margin = '0 auto';
        }
      }
    }catch(e){}

    const onOverlayClick = (ev)=>{ if(ev.target === menu){ closeBulkEditor(); } };
    menu.__overlayClickHandler = onOverlayClick;
    menu.addEventListener('click', onOverlayClick);

    menu.onclick = (ev)=>{
      const add = ev.target.closest('#editorAddRow') || ev.target.closest('.editorAdd');
      if(add){
        SYMBOLS.push('NEW');
        MY_AVG_PRICE['NEW'] = null; MY_LIQ_PRICE['NEW'] = null; SYMBOL_FORMAT['NEW'] = DEFAULT_NUM_FORMAT;
        renderRows();
        try{ adjustEditorColumnWidths(); }catch(e){}
  const lastIdx = SYMBOLS.length-1;
  setTimeout(()=>{ const inp = body.querySelector(`input.sym[data-idx="${lastIdx}"]`); inp?.focus(); inp?.select(); }, 10);
        return;
      }
      const delBtn = ev.target.closest('.editorDel');
      const delWrap = ev.target.closest('.editorDelWrap');
      const el = delBtn || delWrap;
      if(el){
        const i = Number(el.dataset.idx); if(!Number.isNaN(i)){
          const sym = SYMBOLS[i]; SYMBOLS.splice(i,1);
          delete MY_AVG_PRICE[sym]; delete MY_LIQ_PRICE[sym]; delete SYMBOL_FORMAT[sym];
          renderRows();
          try{ adjustEditorColumnWidths(); }catch(e){}
        }
      }
    };
    document.getElementById('editorCancel').onclick = ()=>{ closeBulkEditor(); };
    // Add Reset button handler if present
    const resetBtn = document.getElementById('editorReset'); if(resetBtn) resetBtn.onclick = ()=>{
      try{ localStorage.removeItem(STORAGE_KEY); location.reload(); }catch(e){}
    };

    document.getElementById('editorSave').onclick = ()=>{
      const inputs = Array.from(body.querySelectorAll('input'));
      const next = [];
      const nextAvg = {};
      const nextLiq = {};
      const nextFmt = {};
      const rows = new Map();
      inputs.forEach(inp=>{
        const idx = Number(inp.dataset.idx); const field = inp.dataset.field; let val = inp.value;
        if(field==='avg' || field==='liq'){ const cleaned = String(val).replace(/[_,\s]/g,''); val = cleaned === '' ? '' : cleaned; }
        if(!rows.has(idx)) rows.set(idx, {});
        rows.get(idx)[field] = val;
      });
      for(const [,r] of Array.from(rows.entries()).sort((a,b)=>a[0]-b[0])){
        const sym = (r.sym||'').trim().toUpperCase(); if(!sym) continue;
        if(next.includes(sym)) continue;
        next.push(sym);
        const a = r.avg===''?null: Number(r.avg);
        const l = r.liq===''?null: Number(r.liq);
        const f = (r.fmt||'').trim() || DEFAULT_NUM_FORMAT;
        if(a!=null) nextAvg[sym]=a; else nextAvg[sym]=null;
        if(l!=null) nextLiq[sym]=l; else nextLiq[sym]=null;
        nextFmt[sym]=f;
      }

      SYMBOLS = next.length? next : SYMBOLS;
      for(const k of Object.keys(MY_AVG_PRICE)) delete MY_AVG_PRICE[k];
      for(const k of Object.keys(MY_LIQ_PRICE)) delete MY_LIQ_PRICE[k];
      for(const k of Object.keys(SYMBOL_FORMAT)) delete SYMBOL_FORMAT[k];
      Object.assign(MY_AVG_PRICE, nextAvg);
      Object.assign(MY_LIQ_PRICE, nextLiq);
      Object.assign(SYMBOL_FORMAT, nextFmt);

      rebuildStoresForSymbols();
  try{ savePersisted(); }catch(e){}
  closeBulkEditor();
    };
    try{ adjustEditorColumnWidths(); }catch(e){}
    if(!window.__bulkEditorResizeAttached){ window.addEventListener('resize', adjustEditorColumnWidths); window.__bulkEditorResizeAttached = true; }
  }

  function closeBulkEditor(){
    const m=document.getElementById('ctxMenu'); if(!m) return; 
    try{ if(m.__overlayClickHandler){ m.removeEventListener('click', m.__overlayClickHandler); delete m.__overlayClickHandler; } }catch(e){}
    m.style.display='none'; m.innerHTML=''; m.className='ctxmenu';
    m.style.position=''; m.style.left=''; m.style.top=''; m.style.transform=''; m.style.width=''; m.style.inset='';
    const ed = m.querySelector('.editor');
    if(ed){ ed.style.margin=''; ed.style.position=''; ed.style.left=''; ed.style.transform=''; ed.style.width=''; ed.style.maxWidth=''; }
    document.body.classList.remove('editor-open');
    _editorOpen = false;
  }

  function toggleBulkEditor(){ if(_editorOpen) closeBulkEditor(); else openBulkEditor(); }

  tbodyEl?.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openBulkEditor(); });
  document.querySelector('.panel-table')?.addEventListener('contextmenu', (e)=>{ e.preventDefault(); openBulkEditor(); });
  // Open bulk editor on right-click anywhere in the document
  document.addEventListener('contextmenu', (e)=>{
    // if the editor is already open, default behavior for closing is handled elsewhere
    try{ e.preventDefault(); openBulkEditor(); }catch(e){}
  });

  /* ---------- CHART ---------- */
  function sizeCanvas(){
    const dpr = Math.max(1, DPR_MAX);
    const cssW = chart.clientWidth || chart.getBoundingClientRect().width;
    const cssH = chart.clientHeight|| chart.getBoundingClientRect().height;
    const pxW = Math.floor(cssW*dpr), pxH = Math.floor(cssH*dpr);
    if(chart.width!==pxW) chart.width=pxW;
    if(chart.height!==pxH) chart.height=pxH;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // overlay matches chart size and uses same device pixel scale
    if(overlay){
      if(overlay.width !== pxW) overlay.width = pxW;
      if(overlay.height !== pxH) overlay.height = pxH;
      overlay.style.width = cssW + 'px'; overlay.style.height = cssH + 'px';
      overlayCtx && overlayCtx.setTransform(dpr,0,0,dpr,0,0);
    }
  }

  function clearOverlay(){ if(!overlayCtx) return; overlayCtx.clearRect(0,0,overlay.width||0, overlay.height||0); }

  // DOM-based chart guide helpers
  const chartGuideEl = document.getElementById('chartGuide');
  function showChartGuide(){ if(!chartGuideEl) return; chartGuideEl.classList.add('visible'); }
  function hideChartGuide(){ if(!chartGuideEl) return; chartGuideEl.classList.remove('visible'); }
  function positionChartGuideByCssX(cssX, padT, ih){
    if(!chartGuideEl) return;
    const rect = chart.getBoundingClientRect();
    const parentRect = panelChart.getBoundingClientRect();
    // cssX is canvas-relative CSS pixels (0..canvas.width).
    // Compute coordinates relative to the positioned parent (.panel-chart)
    const leftRel = (rect.left - parentRect.left) + cssX;
    const topRel = (rect.top - parentRect.top) + padT;
    const height = Math.max(0, ih);
    chartGuideEl.style.left = Math.round(leftRel) + 'px';
    chartGuideEl.style.top = Math.round(topRel) + 'px';
    chartGuideEl.style.height = Math.round(height) + 'px';
    showChartGuide();
  }

  // When debugging, draw small markers on the main chart context so we can visually
  // compare where the main chart actually rendered shapes versus the overlay markers.
  function drawMainDebugMarkers(){
    if(!CHART_DEBUG) return;
    try{
      if(!ctx || !cachedXs || !cachedTopYs) return;
      ctx.save();
      ctx.fillStyle = 'rgba(255,0,0,0.9)';
      const n = Math.min(cachedXs.length, cachedTopYs.length);
      for(let i=0;i<n;i++){
        const dx = cachedXs[i]; const dy = cachedTopYs[i];
        ctx.beginPath(); ctx.arc(dx, dy, 2, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }catch(e){}
  }

  /* ---------- TOOLTIP HOOKS ---------- */
  const tooltipEl = document.getElementById('chartTooltip');
  // hoverIndex: currently hovered data index for drawing guide line
  let hoverIndex = null;

  function showTooltip(html, clientX, clientY, anchorType='cursor', anchorTopY=null){
    if(!tooltipEl) return;
    tooltipEl.innerHTML = html;
    tooltipEl.style.display = 'block';
    tooltipEl.classList.add('visible');
    tooltipEl.setAttribute('aria-hidden','false');
    positionTooltip(clientX, clientY, anchorType, anchorTopY);
  }
  function hideTooltip(){ if(!tooltipEl) return; tooltipEl.classList.remove('visible'); tooltipEl.setAttribute('aria-hidden','true'); setTimeout(()=>{ if(tooltipEl) tooltipEl.style.display='none'; }, 120); }

  function positionTooltip(pageX, pageY, anchorType, anchorTopY=null){
    if(!tooltipEl) return;
    const pad = 8;
    const vw = window.innerWidth, vh = window.innerHeight;
    const ttW = tooltipEl.offsetWidth, ttH = tooltipEl.offsetHeight;
    let left, top;
    if(anchorType === 'point'){
      // center horizontally above the point
      left = pageX - Math.round(ttW/2);
      // If an anchorTopY (topmost drawn pixel for point) is supplied, place tooltip bottom a few pixels above it
      if(anchorTopY != null){
        top = anchorTopY - ttH - 8; // 8px gap above the topmost visual element
      } else {
        top  = pageY - ttH - 12;
      }
    } else {
      // cursor-style: offset to the right and above the cursor
      left = pageX + 12;
      top  = pageY - ttH - 12;
    }
    // clamp to viewport
    if(left + ttW + pad > vw) left = Math.max(pad, vw - ttW - pad);
    if(left < pad) left = pad;
    if(top < pad) top = pageY + 12; // if going off top, put below the anchor
    if(top + ttH + pad > vh) top = Math.max(pad, vh - ttH - pad);
    tooltipEl.style.left = Math.round(left) + 'px';
    tooltipEl.style.top  = Math.round(top) + 'px';
  }

  function canvasToDataCoord(clientX, clientY){
    const rect = chart.getBoundingClientRect();
    const cssX = clientX - rect.left; const cssY = clientY - rect.top;
    const w = chart.clientWidth, h = chart.clientHeight;
    const padRcss = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--chart-pad-r"))||16;
    const padLbase= parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--chart-pad-l-base"))||100;
    const cssNudge = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--chart-left-nudge")) || 0;
    const padL = Math.max(Math.round(padLbase + cssNudge), 0);
    const padR = Math.round(padRcss);
    const padT = 14, padB = 28;
    const iw = Math.max(0, w - padL - padR);
    const ih = Math.max(0, h - padT - padB);
    return { cssX, cssY, padL, padT, iw, ih, w, h };
  }

  function findNearestPoint(clientX, clientY){
    const sym = SYMBOLS[_selected_idx];
    const series = chart_series[sym]||[];
    const times = chart_times[sym]||[];
    const c = canvasToDataCoord(clientX, clientY);
    const { cssX, padL, iw } = c;
    const n = series.length;
    if(n===0) return null;
    const xToIndex = (x)=>{
      const rel = (x - padL) / (n>1 ? iw : 1);
      const idx = Math.round(rel * (n-1));
      return Math.max(0, Math.min(n-1, idx));
    };
    const idx = xToIndex(cssX);
    const rect = chart.getBoundingClientRect();
    // If we cached pixel coords during drawChart, prefer them to avoid tiny rounding mismatches
    if(cachedXs && cachedXs.length === n && cachedTopYs && cachedTopYs.length === n){
      const clientDataX = Math.round(rect.left + cachedXs[idx]);
      const clientDataY = Math.round(rect.top + cachedTopYs[idx]);
      const clientTopY = clientDataY;
      return { idx, price: series[idx], time: times[idx], clientX: clientDataX, clientY: clientDataY, clientTopY };
    }
    // fallback
    const dataX = padL + (n>1 ? (idx/(n-1))*iw : iw/2);
    const dataY = c.padT + (1 - (series[idx]-minV_global)/Math.max(1e-9, maxV_global-minV_global))*c.ih;
    const clientDataX = Math.round(rect.left + dataX);
    const clientDataY = Math.round(rect.top + dataY);
    const clientTopY = clientDataY;
    return { idx, price: series[idx], time: times[idx], clientX: clientDataX, clientY: clientDataY, clientTopY };
  }

  function hitTestCandle(clientX, clientY){
    const sym = SYMBOLS[_selected_idx];
    const candles = chart_candles[sym]||[];
    const c = canvasToDataCoord(clientX, clientY);
    const { cssX, cssY, padL, padT, iw, ih, w, h } = c;
    const n = candles.length; if(n===0) return null;
    const candleW = Math.max(2, Math.min(24, Math.floor(iw / Math.max(6, n) * 0.7)));
    for(let i=0;i<n;i++){
      const cx = padL + (i/(n-1 || 1))*iw;
      const openY = yForCanvas(candles[i].o, padT, ih, minV_global, maxV_global);
      const closeY = yForCanvas(candles[i].c, padT, ih, minV_global, maxV_global);
      const highY = yForCanvas(candles[i].h, padT, ih, minV_global, maxV_global);
      const lowY  = yForCanvas(candles[i].l, padT, ih, minV_global, maxV_global);
      const bx = Math.round(cx - candleW/2);
      const by = Math.round(Math.min(openY, closeY));
      const bh = Math.max(1, Math.round(Math.abs(closeY - openY)));
      const top = by, left = bx, right = bx + candleW, bottom = by + bh;
      const rect = chart.getBoundingClientRect();

      // 1) Body hit: inside rectangle -> anchor to close price Y
      if(clientX >= rect.left + left && clientX <= rect.left + right && clientY >= rect.top + top && clientY <= rect.top + bottom){
        let clientXc, clientYc, clientTopY;
        if(cachedXs && cachedXs.length === n && cachedTopYs && cachedTopYs.length === n){
          // Use cached (float) canvas-relative coords so overlay and tooltip anchor exactly match the drawn shapes
          clientXc = rect.left + cachedXs[i];
          clientTopY = rect.top + cachedTopYs[i];
          clientYc = rect.top + closeY;
        } else {
          clientXc = rect.left + cx;
          clientYc = rect.top + closeY;
          clientTopY = rect.top + highY;
        }
        return { idx:i, candle:candles[i], clientX: clientXc, clientY: clientYc, clientTopY };
      }

      // 2) Wick hit: allow a small horizontal tolerance around the wick x and vertical between high/low
      const WICK_HIT_RADIUS = Math.max(3, Math.floor(candleW * 0.5));
      if(clientX >= rect.left + cx - WICK_HIT_RADIUS && clientX <= rect.left + cx + WICK_HIT_RADIUS && clientY >= rect.top + Math.round(highY) && clientY <= rect.top + Math.round(lowY)){
        let clientXc, clientYc, clientTopY;
        if(cachedXs && cachedXs.length === n && cachedTopYs && cachedTopYs.length === n){
          clientXc = rect.left + cachedXs[i];
          clientTopY = rect.top + cachedTopYs[i];
          clientYc = rect.top + closeY;
        } else {
          clientXc = rect.left + cx;
          clientYc = rect.top + closeY;
          clientTopY = rect.top + highY;
        }
        return { idx:i, candle:candles[i], clientX: clientXc, clientY: clientYc, clientTopY };
      }
    }
    return null;
  }

  // helpers used by hitTestCandle (we need global min/max used while drawing)
  let minV_global = 0, maxV_global = 1;
  // Cached per-index canvas pixel coordinates filled by drawChart()
  // - cachedXs: x coordinate in canvas CSS pixels (relative to canvas left)
  // - cachedTopYs: topmost visual pixel Y (padT + highY) in canvas CSS pixels
  let cachedXs = [], cachedTopYs = [];
  function yForCanvas(v, padT, ih, minV, maxV){ return padT + (1 - (v-minV)/Math.max(1e-9, maxV-minV))*ih; }

  // Update globals before drawChart finishes, so hit-testing can use same scale
  const origDrawChart = drawChart;
  // wrap drawChart to capture min/max into globals (safe since drawChart declared earlier)
  // But drawChart is defined later; instead, patch _after_ drawChart: attach an event to update globals in render loop below.

  // Pointer handlers (rAF-throttled to avoid high-frequency work)
  let pointerActive = false;
  let _pendingPointer = null;
  let _pointerRaf = null;

  function _processPointerEvent(ev){
    try{
      const sym = SYMBOLS[_selected_idx];
      let npt = null;
      if(CHART_MODE === 'candle'){
        // prefer precise candle hit-test (body/wick), fall back to nearest point
        npt = hitTestCandle(ev.clientX, ev.clientY) || findNearestPoint(ev.clientX, ev.clientY);
      } else {
        npt = findNearestPoint(ev.clientX, ev.clientY);
      }

      if(npt){
        const idx = Math.max(0, Math.min((npt.idx || 0), Number.MAX_SAFE_INTEGER));
        hoverIndex = idx;

        if(CHART_MODE === 'candle'){
          const candles = chart_candles[sym] || [];
          const c = candles[idx] || { t: npt.time, o: npt.price, h: npt.price, l: npt.price, c: npt.price };
          const spec = SYMBOL_FORMAT[sym] || DEFAULT_NUM_FORMAT;
          const html = `
            <span class="tt-line">${sym} • ${fmtTs(c.t, { seconds: true, showDate: true })}</span>
            <span class="tt-line">C ${formatWithSpec(c.c, spec)}</span>
            <span class="tt-line">O ${formatWithSpec(c.o, spec)}</span>
            <span class="tt-line">H ${formatWithSpec(c.h, spec)}</span>
            <span class="tt-line">L ${formatWithSpec(c.l, spec)}</span>
          `;
          // ensure anchorTopY references the topmost visual pixel for the candle (highY)
          let anchorTop = (npt.clientTopY != null) ? npt.clientTopY : null;
          if(anchorTop == null && candles[idx]){
            try{
              const rect = chart.getBoundingClientRect();
              const ccoords = canvasToDataCoord(ev.clientX, ev.clientY);
              const highY = yForCanvas(candles[idx].h, ccoords.padT, ccoords.ih, minV_global, maxV_global);
              anchorTop = Math.round(rect.top + highY);
            }catch(e){ anchorTop = npt.clientY; }
          }
          if(npt.clientX != null && npt.clientY != null) showTooltip(html, npt.clientX, npt.clientY, 'point', anchorTop);
          else showTooltip(html, ev.clientX, ev.clientY, 'cursor');
          return;
        } else {
          const spec = SYMBOL_FORMAT[sym] || DEFAULT_NUM_FORMAT;
          const html = `<span class="tt-line">${sym} • ${fmtTs(npt.time, { seconds: true, showDate: true })}</span><span class="tt-price">${formatWithSpec(npt.price, spec)}</span>`;
          const anchorTop = (npt.clientTopY != null) ? npt.clientTopY : npt.clientY;
          if(npt.clientX != null && npt.clientY != null) showTooltip(html, npt.clientX, npt.clientY, 'point', anchorTop);
          else showTooltip(html, ev.clientX, ev.clientY, 'cursor');
          return;
        }
      }

      hoverIndex = null;
      hideTooltip();
    }catch(e){ hoverIndex = null; hideTooltip(); }
  }

  chart.addEventListener('pointermove', (ev)=>{
    pointerActive = true;
    // immediate overlay draw for instant guide-line responsiveness
    try{
      const c = canvasToDataCoord(ev.clientX, ev.clientY);
      const n = (CHART_MODE === 'candle') ? (chart_candles[SYMBOLS[_selected_idx]]||[]).length : (chart_series[SYMBOLS[_selected_idx]]||[]).length;
      if(n>0){
        // Use the same hit-test logic as the tooltip to pick the index. This avoids divergence
        // between the overlay index and the tooltip/hit-test index caused by small rounding differences.
        let npt = null;
        if(CHART_MODE === 'candle') npt = hitTestCandle(ev.clientX, ev.clientY) || findNearestPoint(ev.clientX, ev.clientY);
        else npt = findNearestPoint(ev.clientX, ev.clientY);
        let idx = null;
        if(npt && typeof npt.idx === 'number') idx = Math.max(0, Math.min(n-1, npt.idx));
        // Prefer cached X if available (cachedXs are stored as DPR-aligned CSS floats)
        const useCached = (idx!=null && cachedXs && cachedXs.length === n);
        const gx = useCached ? cachedXs[idx] : (c.padL + (n>1 ? ((idx!=null?idx:0)/(n-1))*c.iw : c.iw/2));
        // Position the DOM guide using canvas-relative CSS X
        positionChartGuideByCssX(gx, c.padT, c.ih);
        // Optionally draw debug markers onto overlay canvas when CHART_DEBUG is enabled
        if(CHART_DEBUG && overlayCtx && typeof idx === 'number' && cachedXs && cachedTopYs && idx>=0 && idx<cachedXs.length){
          try{ clearOverlay(); overlayCtx.save(); overlayCtx.fillStyle='rgba(255,0,0,0.9)'; overlayCtx.beginPath(); overlayCtx.arc(cachedXs[idx], cachedTopYs[idx], 3, 0, Math.PI*2); overlayCtx.fill(); overlayCtx.restore(); }catch(e){}
        } else if(CHART_DEBUG){ clearOverlay(); }
      }
    }catch(e){}

    _pendingPointer = ev;
    if(_pointerRaf) return;
    _pointerRaf = requestAnimationFrame(()=>{
      _pointerRaf = null;
      const ev2 = _pendingPointer;
      _pendingPointer = null;
      if(ev2) _processPointerEvent(ev2);
    });
  }, {passive:true});

  // Support touch/pen: show tooltip immediately on pointerdown (tap), keep it until pointerup/cancel
  chart.addEventListener('pointerdown', (ev)=>{
    pointerActive = true;
    try{ _processPointerEvent(ev); }catch(e){}
  }, {passive:true});

  chart.addEventListener('pointerup', (ev)=>{ pointerActive = false; /* keep tooltip visible briefly, but don't force-hide here */ }, {passive:true});
  chart.addEventListener('pointercancel', (ev)=>{ pointerActive = false; hoverIndex = null; hideTooltip(); }, {passive:true});

  chart.addEventListener('pointerleave', ()=>{ pointerActive=false; hoverIndex = null; hideTooltip(); clearOverlay(); hideChartGuide(); });


  function updateChartAnchors(){
    const headerCells = Array.from(theadEl.querySelectorAll("th")).filter(th=>{
      const cs = getComputedStyle(th);
      return cs.display!=="none" && th.getClientRects().length>0;
    });
    if(headerCells.length===0) return;

    const lastTh = headerCells[headerCells.length-1];
    const lastRect = lastTh.getBoundingClientRect();
    const lastPadR = parseFloat(getComputedStyle(lastTh).paddingRight)||8;

    const chartRect = chart.getBoundingClientRect();
    const wrap = document.querySelector('.table-wrap');
    const scrollLeft = wrap ? wrap.scrollLeft : 0;
    const rightDataX = lastRect.right - lastPadR + scrollLeft;
    const padR = Math.max(0, Math.round(chartRect.right - rightDataX));
    document.documentElement.style.setProperty("--chart-pad-r", padR+"px");

    const coinTh = theadEl.querySelector(".h-coin") || headerCells[0];
    const coinRect = coinTh.getBoundingClientRect();
    const coinPadL = parseFloat(getComputedStyle(coinTh).paddingLeft)||8;
    const leftDataX = coinRect.left + coinPadL + (wrap ? wrap.scrollLeft : 0);
    const padLBase = Math.max(0, Math.round(leftDataX - chartRect.left));
    document.documentElement.style.setProperty("--chart-pad-l-base", padLBase+"px");

  // axis is now part of the legend and aligned via flex layout; no absolute positioning required
  }

  function drawChart(){
    // If overlay is visible (loading), avoid rendering the previous chart contents to prevent showing stale data.
    const overlayNow = !!document.querySelector('.panel-chart .loading-overlay.visible');
    if(overlayNow){
      // keep canvas intact but draw a neutral backdrop so the spinner is the only visible element
      const w = chart.clientWidth, h = chart.clientHeight;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = 'rgba(11,13,16,0.6)';
      ctx.fillRect(0,0,w,h);
      return;
    }
    if(!SHOW_CHART){
      panelChart.style.display="none";
      updateHints();
      return;
    }
    panelChart.style.display="";
    try{ updateChartAnchors(); }catch{}
    updateHints();

  const sym = SYMBOLS[_selected_idx];
  const series = chart_series[sym]||[];
  const lbLabel = (LOOKBACKS_CHART[CHART_LOOKBACK_IDX] && LOOKBACKS_CHART[CHART_LOOKBACK_IDX][0]) || '24h';
  // update legend with prev / current / next period previews
  try{
    const legend = document.getElementById('chartLegend');
    if(legend){
      // Subsections
      const tokenEl = document.getElementById('chartToken');
      const periodsEl = document.getElementById('chartPeriods');
      const granEl = document.getElementById('chartGranularity');
      const axisEl = document.getElementById('chartAxis');

      // Token (left)
      if(tokenEl) tokenEl.textContent = sym;

      // Periods (center-left): render all available periods as clickable items
      const iv = getChartInterval();
      if(periodsEl){
        // Only rebuild the periods items if the selected index changed or we haven't rendered them yet
        if(LAST_CHART_PERIODS_IDX === null || LAST_CHART_PERIODS_IDX !== CHART_LOOKBACK_IDX){
          periodsEl.innerHTML = LOOKBACKS_CHART.map(([lb,secs], idx)=>{
            const sel = (idx === CHART_LOOKBACK_IDX) ? ' selected' : '';
            return `<span role="button" tabindex="0" class="muted legend-period-item${sel}" data-idx="${idx}" title="Switch to ${lb}">${lb}</span>`;
          }).join('');

          // attach handlers
          const items = Array.from(periodsEl.querySelectorAll('.legend-period-item'));
          items.forEach(it=>{
            it.style.cursor = 'pointer';
            it.addEventListener('click', async ()=>{
              const idx = Number(it.dataset.idx);
              if(idx === CHART_LOOKBACK_IDX) return; // no-op
              CHART_LOOKBACK_IDX = idx;
              try{ if(SHOW_CHART){ showChartOverlayInstant(); debouncedRefreshCharts(); _changed=true; /* defer draw until data arrives */ } }catch(e){}
              try{ savePersisted(); }catch(e){}
            });
            it.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter' || ev.key===' '){ ev.preventDefault(); it.click(); } });
          });
          LAST_CHART_PERIODS_IDX = CHART_LOOKBACK_IDX;
        }
      }

      // Granularity (center-right)
      if(granEl){ granEl.textContent = `Granularity — ${iv}`; }

      // Axis (right): populated by renderAxis() below (but set now for initial state)
      if(axisEl){ axisEl.textContent = `${fmtTs(computeAxisRange()[0], { showDate: true })}  —  ${fmtTs(computeAxisRange()[1], { showDate: true })}`; }
    }
  }catch(e){}

  sizeCanvas();
  // clear overlay before full redraw so overlay doesn't persist
  clearOverlay();
    const w = chart.clientWidth, h = chart.clientHeight;
    ctx.clearRect(0,0,w,h);

  // If in candle mode we can render even with a single candle; otherwise need >=2 points for a line
  const candlesAvail = (CHART_MODE === 'candle') && (Array.isArray(chart_candles[sym]) && chart_candles[sym].length > 0);
  if(!(candlesAvail) && (!series || series.length < 2)){
      ctx.fillStyle="#9fb0c0";
      const baseFont = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-font-size')) || 12;
      ctx.font = `${Math.max(10, Math.round(baseFont))}px system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif`;
      ctx.fillText("Waiting for chart data…", 16, Math.floor(h/2));
      renderAxis();
      return;
    }

    const candles = chart_candles[sym] || [];
    const cur = latest_mid[sym];
    // Determine data point count and min/max based on mode
    const dataPoints = (CHART_MODE === 'candle') ? Math.max(0, candles.length) : Math.max(0, series.length);
    let minV, maxV;
    if(CHART_MODE === 'candle' && candles.length){
      minV = Math.min(...candles.map(c=>c.l));
      maxV = Math.max(...candles.map(c=>c.h));
    } else {
      if(series.length){ minV = Math.min(...series); maxV = Math.max(...series); }
      else { minV = cur || 0; maxV = cur || 1; }
    }
    // Avoid zero-range
    if(minV === maxV){ const delta = Math.abs(minV) * 0.001 || 1; minV -= delta; maxV += delta; }
    const spec = SYMBOL_FORMAT[sym]||DEFAULT_NUM_FORMAT;

  // expose min/max for tooltip hit-testing
  minV_global = minV;
  maxV_global = maxV;

    const padRcss = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--chart-pad-r"))||16;
    const padLbase= parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--chart-pad-l-base"))||100;
    const cssNudge = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--chart-left-nudge")) || 0;

    const baseFont = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-font-size')) || 12;
    ctx.font = `${Math.max(10, Math.round(baseFont))}px system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif`;

    const roundPX=v=>Math.round(v);
    const padL = Math.max(roundPX(padLbase + cssNudge), 0);
    const padR = roundPX(padRcss);
    const padT = 14, padB = 28;

  const iw = Math.max(0, w - padL - padR);
  const ih = Math.max(0, h - padT - padB);
  const x = (i)=> padL + (dataPoints>1 ? (i/(dataPoints-1))*iw : iw/2);
    const y = (v)=> padT + (1 - (v-minV)/Math.max(1e-9, maxV-minV))*ih;

    if(cur!=null){
      const yCur = roundPX(y(cur));
      ctx.save();
      ctx.setLineDash([5,4]); ctx.strokeStyle="rgba(134,185,255,.9)"; ctx.lineWidth=1;
      const label = formatWithSpec(cur, spec) || "";
      const labelW = Math.ceil(ctx.measureText(label).width || 0);
      const gap = 8;
      const startX = Math.min(w - padR - 4, padL + labelW + gap);
      const endX = Math.max(startX + 4, w - padR);
      if(startX < endX){ ctx.beginPath(); ctx.moveTo(startX, yCur); ctx.lineTo(endX, yCur); ctx.stroke(); }
      ctx.restore();
    }

  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--fg') || '#0b0d10'; ctx.textAlign="left"; ctx.textBaseline="middle";
    if(maxV!=null) ctx.fillText(formatWithSpec(maxV,spec), padL, roundPX(y(maxV)));
    if(minV!=null) ctx.fillText(formatWithSpec(minV,spec), padL, roundPX(y(minV)));
    if(cur!=null)  ctx.fillText(formatWithSpec(cur,spec),  padL, roundPX(y(cur)));

    if(CHART_MODE === 'candle'){
      // draw candles from chart_candles[sym] using DPR-aligned coordinates
      const candles = chart_candles[sym] || [];
      const n = candles.length;
      cachedXs = new Array(n);
      cachedTopYs = new Array(n);
      if(n>0){
        const candleW = Math.max(2, Math.min(24, Math.floor(iw / Math.max(6, n) * 0.7)));
        const dpr = Math.max(1, DPR_MAX);
        // First pass: compute DPR-aligned centers/top Ys for every candle
        for(let i=0;i<n;i++){
          const cx = padL + (i/(n-1 || 1))*iw;
          const highY = y(candles[i].h);
          const alignedX = (Math.round(cx * dpr) + 0.5) / dpr;
          const alignedTopY = (Math.round(highY * dpr) + 0.5) / dpr;
          cachedXs[i] = alignedX;
          cachedTopYs[i] = alignedTopY;
        }
        // Second pass: draw using aligned coords
        for(let i=0;i<n;i++){
          const c = candles[i];
          const ox = cachedXs[i];
          const openY = y(c.o);
          const closeY = y(c.c);
          const highY = cachedTopYs[i];
          const lowYraw = y(c.l);
          const lowY = (Math.round(lowYraw * dpr) + 0.5) / dpr;
          const isUp = c.c >= c.o;
          ctx.strokeStyle = isUp ? 'rgba(22,199,132,0.9)' : 'rgba(234,57,67,0.9)';
          ctx.fillStyle = isUp ? 'rgba(22,199,132,0.18)' : 'rgba(234,57,67,0.18)';
          ctx.lineWidth = 1;
          // wick - draw aligned
          ctx.beginPath(); ctx.moveTo(ox, highY); ctx.lineTo(ox, lowY); ctx.stroke();
          // body - we align body box by rounding to CSS pixels where appropriate
          const bw = candleW;
          const bx = Math.round(ox - bw/2);
          const by = Math.round(Math.min(openY, closeY));
          const bh = Math.max(1, Math.round(Math.abs(closeY - openY)));
          ctx.fillRect(bx, by, bw, bh);
          ctx.strokeRect(bx+0.5, by+0.5, bw-1, bh-1);
        }
      }
      // guide line is drawn on the overlay for instant responsiveness (avoid duplicate drawing here)
    } else {
      // line mode - compute DPR-aligned points and draw the path
      const n = series.length;
      cachedXs = new Array(n);
      cachedTopYs = new Array(n);
      const dpr = Math.max(1, DPR_MAX);
      for(let i=0;i<n;i++){
        const px = x(i);
        const py = y(series[i]);
        cachedXs[i] = (Math.round(px * dpr) + 0.5) / dpr;
        cachedTopYs[i] = (Math.round(py * dpr) + 0.5) / dpr;
      }
      if(n>0){
        ctx.beginPath(); ctx.moveTo(cachedXs[0], cachedTopYs[0]);
        for(let i=1;i<n;i++) ctx.lineTo(cachedXs[i], cachedTopYs[i]);
        ctx.strokeStyle="#5ca8ff"; ctx.lineWidth=1; ctx.stroke();
      }
      const grad=ctx.createLinearGradient(0,padT,0,padT+ih);
      grad.addColorStop(0,"rgba(134,185,255,.28)");
      grad.addColorStop(1,"rgba(134,185,255,0)");
      ctx.lineTo(padL+iw, padT+ih); ctx.lineTo(padL, padT+ih); ctx.closePath();
      ctx.fillStyle=grad; ctx.fill();

      // guide line is drawn on the overlay for instant responsiveness (avoid duplicate drawing here)
    }

    // If debugging, draw markers on main canvas to compare against overlay
    try{ drawMainDebugMarkers(); }catch(e){}

    renderAxis(); // live axis
  }

  /* ---------- DATA ---------- */
  function intervalSeconds(iv){
    if(iv.endsWith("m")) return parseInt(iv,10)*60;
    if(iv.endsWith("h")) return parseInt(iv,10)*3600;
    if(iv.endsWith("d")) return parseInt(iv,10)*86400;
    if(iv.endsWith("w")) return parseInt(iv,10)*604800;
    if(iv.endsWith("M")) return 30*86400;
    throw new Error("Unsupported interval: "+iv);
  }

  function getChartInterval(){
  // Use unified lookup (same for line and candle) so the data spread matches
  ensureChartIdx();
  const lb = LOOKBACKS_CHART[CHART_LOOKBACK_IDX] ? LOOKBACKS_CHART[CHART_LOOKBACK_IDX][0] : '24h';
  const mapped = INTERVAL_FOR_LOOKBACK[lb];
  if(mapped) return mapped;
  return CHART_MODE === 'candle' ? CHART_CANDLE_INTERVAL : CHART_INTERVAL;
  }

  async function postInfo(payload){
    const ctrl=new AbortController(); const to=setTimeout(()=>ctrl.abort(), HTTP_TIMEOUT_MS);
    try{
      const res=await fetch(INFO_URL,{method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(payload), signal:ctrl.signal, mode:"cors", credentials:"omit"});
      if(!res.ok) throw new Error("HTTP "+res.status);
      return await res.json();
    } finally{ clearTimeout(to); }
  }

  async function fetchCandles(coin, interval, startMs, endMs){
    const payload={type:"candleSnapshot", req:{coin, interval, startTime:startMs, endTime:endMs}};
    const data=await postInfo(payload);
    if(Array.isArray(data)) return data;
    if(data && typeof data==="object"){ const inner=data.data; return Array.isArray(inner)?inner:[]; }
    return [];
  }

  async function fetchPastClose(coin, lbLabel, lbSecs){
    const endMs=nowMs();
  const interval=INTERVAL_FOR_LOOKBACK[lbLabel] || CHART_INTERVAL;
    const intS=intervalSeconds(interval);
    const want=Math.max(20, Math.min(Math.floor(lbSecs/intS)+5, 200));
    const startMs=endMs - want*intS*1000;

    const candles=await fetchCandles(coin, interval, startMs, endMs);
    if(!candles||candles.length===0) return null;

    const times=[], closes=[];
    for(const c of candles){
      try{
        if(c && typeof c==="object" && !Array.isArray(c)){ times.push(+(c.t??c.startTime)); closes.push(+(c.c??c.close)); }
        else if(Array.isArray(c)){ times.push(+c[0]); closes.push(+c[4]); }
      }catch{}
    }
    const target=endMs-lbSecs*1000;
    let idx=0; for(let i=0;i<times.length;i++){ if(times[i]<=target) idx=i; else break; }
    return closes[idx];
  }

  async function refreshAllBaselines(){
  // Fetch baselines for all lookbacks shown in the table (includes 5m/30m)
  await Promise.all(SYMBOLS.flatMap(sym=>LOOKBACKS_TABLE.map(async([lb,secs])=>{
      try{ baselines[sym][lb]=await fetchPastClose(sym,lb,secs); }catch{ baselines[sym][lb]??=null; }
    })));
    _changed=true;
  }

  async function refreshAllCharts(){
  // Guard against out-of-order async fetches by stamping a request id
  const reqId = Math.random().toString(36).slice(2);
  refreshAllCharts.__lastReq = reqId;
  ensureChartIdx();
  const endMs  = nowMs();
  const lookbackSecs = (LOOKBACKS_CHART[CHART_LOOKBACK_IDX] && LOOKBACKS_CHART[CHART_LOOKBACK_IDX][1]) || (24*60*60);
  const startMs= endMs - lookbackSecs*1000;

    const interval = getChartInterval();
    const results = await Promise.all(
      SYMBOLS.map(sym => fetchCandles(sym, interval, startMs, endMs).catch(()=>[]))
    );

  // If another refresh started after we did, abandon applying these results
  if(refreshAllCharts.__lastReq !== reqId) return;
  results.forEach((data, idx) => {
      const sym = SYMBOLS[idx];
      // For line mode we populate series/times (close prices). For candle mode
      // we populate chart_candles with {t,o,h,l,c} objects.
      const series = [], times = [];
      const candles = [];

      if (Array.isArray(data)) {
        for (const c of data) {
          try{
            let ts, open, high, low, close;
            if (c && typeof c === "object" && !Array.isArray(c)) {
              ts = +(c.t ?? c.startTime ?? c[0]);
              open = +(c.o ?? c.open ?? c[1]);
              high = +(c.h ?? c.high ?? c[2]);
              low  = +(c.l ?? c.low ?? c[3]);
              close= +(c.c ?? c.close ?? c[4]);
            } else if (Array.isArray(c)) {
              ts = +c[0]; open = +c[1]; high = +c[2]; low = +c[3]; close = +c[4];
            }
            if (Number.isFinite(ts)) {
              const tms = toMs(ts);
              times.push(tms);
              series.push(close);
              candles.push({ t: tms, o: open, h: high, l: low, c: close });
            }
          }catch{}
        }
      }

      chart_series[sym] = series;
      chart_times[sym]  = times;
      chart_candles[sym] = candles;
      hasSnapshot[sym] = true;

      // apply any buffered live point captured before the snapshot
      const pending = pendingLive[sym];
      if (pending && Number.isFinite(pending.t) && Number.isFinite(pending.price)) {
        if (getChartInterval().endsWith('m') || getChartInterval().endsWith('h') || getChartInterval().endsWith('d')){
          // For both modes, update the last entry with the pending live point
          if (times.length) {
            times[times.length - 1]   = pending.t;
            series[series.length - 1] = pending.price;
            // also adjust candle close/high/low if present
            const lastC = chart_candles[sym] && chart_candles[sym][chart_candles[sym].length-1];
            if(lastC){ lastC.t = pending.t; lastC.c = pending.price; lastC.h = Math.max(lastC.h, pending.price); lastC.l = Math.min(lastC.l, pending.price); }
          } else {
            times.push(pending.t);
            series.push(pending.price);
            chart_candles[sym].push({ t: pending.t, o: pending.price, h: pending.price, l: pending.price, c: pending.price });
          }
        }
        pendingLive[sym] = null;
      }
    });

    _changed = true;
    if(AXIS_DEBUG) console.debug('refreshAllCharts done', {now: nowMs(), selected: SYMBOLS[_selected_idx], hasSnapshot});
    renderAxis(); // sync the label immediately
  }

  // Debounce helper for user-triggered chart refreshes
  function debounce(fn, wait){
    let t = null;
    return function(...args){
      if(t) clearTimeout(t);
      t = setTimeout(()=>{ t = null; fn.apply(this, args); }, wait);
    };
  }

  // Show loading state in legend while a refresh is in flight
  async function refreshAllChartsWithLoading(){
  // Show loading overlay and a loading state in the periods subsection without removing the canvas
  const periodsEl = document.getElementById('chartPeriods');
  const legend = document.getElementById('chartLegend');
  const overlay = document.querySelector('.panel-chart .loading-overlay');
  if(overlay) { overlay.classList.add('visible'); LAST_CHART_PERIODS_IDX = null; }
  try{ await refreshAllCharts(); }catch(e){}
  if(overlay) overlay.classList.remove('visible');
  // drawChart will rebuild/populate subsections and redraw
  drawChart();
  }

  const debouncedRefreshCharts = debounce(refreshAllChartsWithLoading, 240);

  /* ---------- WS ---------- */
  let ws=null, hbTimer=null, reconnTimer=null;
  const startHeartbeat=()=>{ stopHeartbeat(); hbTimer=setInterval(()=>{ try{ws?.send(JSON.stringify({method:"ping"}));}catch{} }, HEARTBEAT_SECONDS * 1000); };
  const stopHeartbeat =()=>{ if(hbTimer){clearInterval(hbTimer); hbTimer=null;} };
  const scheduleReconnect=()=>{ if(reconnTimer) return; reconnTimer=setTimeout(()=>{reconnTimer=null; connectWs();}, RECONNECT_DELAY_MS); };

  function connectWs(){
    try{ ws?.close(); }catch{}
    ws=new WebSocket(WS_URL);
    ws.onopen=()=>{ stopHeartbeat(); ws.send(JSON.stringify({method:"subscribe", subscription:{type:"allMids"}})); startHeartbeat(); };
    ws.onmessage=(ev)=>{
      try{
        const msg=JSON.parse(ev.data);
        if(msg.channel==="allMids"){
          const mids=(msg.data?.mids)||{}; let updated=false; const ts=nowMs();
          for(const s of SYMBOLS){
            const v=mids[s]; if(v==null) continue;
            const f=Number(v); if(!Number.isFinite(f)) continue;
            if(latest_mid[s]!==f){ latest_mid[s]=f; last_mid_ts[s]=ts; updated=true; }
          }
          if (updated) {
            if (SHOW_CHART) {
              for (const s of SYMBOLS) {
                if (latest_mid[s] != null) updateLiveTail(s);
              }
            }
            _changed = true;
          }
        }
      }catch{}
    };
    ws.onclose=()=>{ stopHeartbeat(); scheduleReconnect(); };
    ws.onerror=()=>{ try{ws.close();}catch{} };
  }

  function updateLiveTail(sym){
    // If we haven't received a snapshot yet, buffer the live point and wait.
    if(!hasSnapshot[sym]){
      pendingLive[sym] = { t: nowMs(), price: latest_mid[sym] };
      if(AXIS_DEBUG) console.debug('updateLiveTail buffered', {sym, t: pendingLive[sym].t, price: pendingLive[sym].price});
      return;
    }

    const tNow = nowMs();
    const interval = getChartInterval();
    const ivMs = intervalSeconds(interval) * 1000;

    if (CHART_MODE === 'candle'){
      // update candles array
      const candles = chart_candles[sym] || [];
      if(!candles.length || (tNow - (candles[candles.length-1].t || 0) >= ivMs)){
        // start new candle
        candles.push({ t: tNow, o: latest_mid[sym], h: latest_mid[sym], l: latest_mid[sym], c: latest_mid[sym] });
      } else {
        const last = candles[candles.length-1];
        last.t = tNow;
        last.c = latest_mid[sym];
        if(latest_mid[sym] > last.h) last.h = latest_mid[sym];
        if(latest_mid[sym] < last.l) last.l = latest_mid[sym];
      }
  // trim to selected lookback
  const lookbackSecs = (LOOKBACKS_CHART[CHART_LOOKBACK_IDX] && LOOKBACKS_CHART[CHART_LOOKBACK_IDX][1]) || (24*60*60);
  const cutoff = tNow - lookbackSecs*1000;
      while(candles.length && candles[0].t < cutoff) candles.shift();
      chart_candles[sym] = candles;

      // also keep series/times for compatibility (use close prices)
      const times = chart_times[sym] || [];
      const series = chart_series[sym] || [];
      if(!times.length || (tNow - (times[times.length-1]||0) >= ivMs)){
        times.push(tNow); series.push(latest_mid[sym]);
      } else {
        times[times.length-1] = tNow; series[series.length-1] = latest_mid[sym];
      }
  // trim
  while(times.length && times[0] < cutoff){ times.shift(); series.shift(); }
      chart_times[sym]=times; chart_series[sym]=series;
    } else {
      // line mode: same as before but use current interval
      let series = chart_series[sym];
      let times  = chart_times[sym];
      if(!series) series = chart_series[sym]=[];
      if(!times)  times  = chart_times[sym]=[];
      if (tNow - (times[times.length - 1] || 0) < ivMs) {
        times[times.length - 1]   = tNow;
        series[series.length - 1] = latest_mid[sym];
      } else {
        times.push(tNow);
        series.push(latest_mid[sym]);
      }

  // keep only last lookback window
  const lookbackSecs = (LOOKBACKS_CHART[CHART_LOOKBACK_IDX] && LOOKBACKS_CHART[CHART_LOOKBACK_IDX][1]) || (24*60*60);
  const cutoff = tNow - lookbackSecs*1000;
  while (times.length && times[0] < cutoff) { times.shift(); series.shift(); }
    }

    renderAxis();
  }

  /* ---------- INPUT ---------- */
  function moveSelection(delta){
    if(!SHOW_CHART) return;
    const n=SYMBOLS.length;
    _selected_idx = (_selected_idx + delta + n) % n;
    updateSelectionDots();
    drawChart();
  }
  function applyChartClass(){
    document.body.classList.toggle('chart-off', !SHOW_CHART);
    try{ updateColumnWidths(); }catch(e){}
    setTimeout(()=>{
      try{
        const wrap = document.querySelector('.table-wrap');
        if(wrap && !SHOW_CHART){ wrap.scrollLeft = 0; }
        updateColumnWidths(); updateChartAnchors(); drawChart();
      }catch(e){}
    }, 24);
  }
  async function toggleChart(){
    SHOW_CHART = !SHOW_CHART;
    applyChartClass();
  if(SHOW_CHART){ debouncedRefreshCharts(); }
    updateSelectionDots();
    drawChart();
  try{ savePersisted(); }catch(e){}
  }
  function updateHints(){ if(hintSwitch) hintSwitch.style.display = SHOW_CHART ? "" : "none"; }

  // Global keyboard shortcuts
  window.addEventListener("keydown", async (e)=>{
    if(e.key === 'Escape'){
      const m = document.getElementById('ctxMenu');
      if(m && m.classList.contains('bulk-editor')){ e.preventDefault(); closeBulkEditor(); return; }
      return;
    }
    const tag=(e.target?.tagName||"").toLowerCase();
    if(tag==="input"||tag==="textarea"||e.isComposing) return;
    if(e.key==="c"||e.key==="C"){ e.preventDefault(); await toggleChart(); return; }
  if(e.key==="e"||e.key==="E"){ e.preventDefault(); toggleBulkEditor(); return; }
  if(e.key==="t"||e.key==="T"){ e.preventDefault(); THEME = (THEME === 'light' ? 'dark' : 'light'); applyTheme(); try{ savePersisted(); }catch(e){} drawChart(); updateTable(); return; }
  if(e.key==="d"||e.key==="D"){ e.preventDefault(); CHART_DEBUG = !CHART_DEBUG; clearOverlay(); drawChart(); return; }
    if(e.key==="v"||e.key==="V"){ e.preventDefault();
  // toggle between line and candle modes
  CHART_MODE = (CHART_MODE === 'line') ? 'candle' : 'line';
  // refresh chart data using appropriate interval (debounced)
    try{ if(SHOW_CHART){ showChartOverlayInstant(); debouncedRefreshCharts(); _changed=true; } }catch(e){}
  try{ savePersisted(); }catch(e){}
      return;
    }
    if(!SHOW_CHART) return;
    if(e.key==="ArrowUp"){ e.preventDefault(); moveSelection(-1); }
    else if(e.key==="ArrowDown"){ e.preventDefault(); moveSelection(+1); }
    else if(e.key==="ArrowLeft"){ e.preventDefault();
      // move to previous lookback
  CHART_LOOKBACK_IDX = (CHART_LOOKBACK_IDX - 1 + LOOKBACKS_CHART.length) % LOOKBACKS_CHART.length;
    try{ if(SHOW_CHART){ showChartOverlayInstant(); debouncedRefreshCharts(); _changed=true; } }catch(e){}
  try{ savePersisted(); }catch(e){}
    }
    else if(e.key==="ArrowRight"){ e.preventDefault();
      // move to next lookback
  CHART_LOOKBACK_IDX = (CHART_LOOKBACK_IDX + 1) % LOOKBACKS_CHART.length;
    try{ if(SHOW_CHART){ showChartOverlayInstant(); debouncedRefreshCharts(); _changed=true; } }catch(e){}
  try{ savePersisted(); }catch(e){}
    }
  }, {capture:true});

  /* Resize + table scroll keep chart anchored to table */
  window.addEventListener("resize", ()=>{ updateColumnWidths(); updateChartAnchors(); drawChart(); });
  const _tblWrap = document.querySelector('.table-wrap');

  // rAF-throttled horizontal scroll updates
  let _scrollRaf = null;
  _tblWrap?.addEventListener('scroll', ()=>{
    if (_scrollRaf) return;
    _scrollRaf = requestAnimationFrame(()=>{
      _scrollRaf = null;
      updateChartAnchors();
      drawChart();
    });
  }, {passive:true});

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      renderAxis();
      drawChart();
    }
  });
  window.addEventListener('focus', () => {
    renderAxis();
    drawChart();
  });

  /* ---------- LIGHT PER-SECOND UPDATES ---------- */
  function tickAxis(){
    try{ if(clockEl) clockEl.textContent = fmtClock(); }catch(e){}
    if(!SHOW_CHART) return;
    renderAxis();
  }
  setInterval(tickAxis, 1000);

  /* ---------- RENDER LOOP ---------- */
  function renderIfDue(){
    const now=nowMs();
    if(now-_last_render_time<RENDER_MIN_INTERVAL && !_changed) return;
    _last_render_time=now; _changed=false;
    updateTable();
    updateChartAnchors();
    drawChart();
  }
  setInterval(renderIfDue, LOWPOWER?250:120);

  /* ---------- MAIN ---------- */
  async function main(){
  try{ loadPersisted(); }catch(e){}
  try{ ensureChartIdx(); }catch(e){}
  applyTheme();
  buildTableHeader();
    hydrateTable();
    connectWs();
    try{ await refreshAllBaselines(); }catch{}
    if(SHOW_CHART){ try{ await refreshAllCharts(); }catch{} }
    updateHints();
    applyChartClass();
    renderIfDue();

    setInterval(async()=>{ try{ await refreshAllBaselines(); _changed=true; }catch{} }, BASELINE_REFRESH_SECONDS*1000);
    setInterval(async()=>{ try{ if(SHOW_CHART){ await refreshAllCharts(); _changed=true; } }catch{} }, CHART_REFRESH_SECONDS*1000);
  }
  main();
})();
</script>
</body>
</html>
